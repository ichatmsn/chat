<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>iChat</title>
    <meta name="theme-color" content="#007aff">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Chat">
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" sizes="192x192" href="./icon-192.png">
    <link rel="apple-touch-icon" sizes="180x180" href="./icon-192.png">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        /* Asegurar que html y body ocupen toda la altura de la ventanaa */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevenir scroll del body */
            /* Establecer la fuente principal */
            font-family: 'Roboto', sans-serif; /* Usar Roboto, con sans-serif como fallback moderno */
            background-color: #f2f2f7; /* Fondo neutro para PC */
        }

        body {
            display: flex;
            justify-content: center;
            padding: 20px; /* En PC da aire alrededor del chat */
            box-sizing: border-box;
        }

        /* Estilos generales y de contenedor */
        #chat-container {
            width: 100%; /* Ocupar todo el ancho disponible hasta el max-width */
            max-width: 700px; /* Aumentar el ancho máximo */
            background-color: #ffffff; /* Fondo blanco limpio */
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); /* Sombra más suave */
            border-radius: 15px; /* Bordes más redondeados */
            overflow: hidden;
            display: flex;
            flex-direction: column;
            /* Altura inicial al 100% del viewport */
            height: calc(100vh - 40px); /* Considera el padding del body en PC */
            max-height: calc(100vh - 40px); /* Asegurar que no exceda el viewport */
            box-sizing: border-box;
            padding: 0; /* Evita desalineación con el área fija inferior */
        }

        /* Estilos para la sección de ingreso de nombre */
        #name-prompt {
            padding: 30px 20px; /* Más padding */
            text-align: center;
            background-color: #e5e5ea; /* Gris claro */
            border-bottom: 1px solid #d1d1d6; /* Borde sutil */
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            flex: 1 1 auto;
            max-height: 100%;
            overflow: hidden;
        }

        #name-prompt h2 {
            margin-top: 0;
            color: #1c1c1e; /* Texto oscuro */
            font-size: 1.5em; /* Aumentar tamaño del título */
        }

        #name-prompt input {
            padding: 12px 15px; /* Más padding */
            border: 1px solid #d1d1d6;
            border-radius: 8px; /* Bordes redondeados */
            font-size: 1.1em; /* Aumentar tamaño de fuente */
            box-sizing: border-box; /* Incluir padding y border */
            width: 80%;
            max-width: 300px;
        }

        #name-prompt #start-chat-button {
            padding: 13px 32px;
            background: linear-gradient(135deg, #007aff 0%, #0051d5 100%);
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: 600;
            letter-spacing: 0.3px;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 14px rgba(0,122,255,0.35);
        }

        #name-prompt #start-chat-button:hover {
            background: linear-gradient(135deg, #0062d1 0%, #003fa3 100%);
            box-shadow: 0 6px 20px rgba(0,122,255,0.45);
            transform: translateY(-1px);
        }
        #name-prompt #start-chat-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(0,122,255,0.3);
        }

        /* Zumbido / Nudge (MSN style) */
        @keyframes nudge-shake {
            0% { transform: translate(0,0); }
            5% { transform: translate(-8px, -6px); }
            10% { transform: translate(8px, 4px); }
            15% { transform: translate(-6px, 6px); }
            20% { transform: translate(6px, -4px); }
            25% { transform: translate(-4px, 4px); }
            30% { transform: translate(4px, -2px); }
            35% { transform: translate(-2px, 2px); }
            40% { transform: translate(2px, -1px); }
            45% { transform: translate(-1px, 1px); }
            50% { transform: translate(0,0); }
            100% { transform: translate(0,0); }
        }
        .nudge-shaking {
            animation: nudge-shake 0.375s ease-in-out 8;
        }
        .nudge-message {
            text-align: center;
            font-size: 0.82em;
            color: #ff9500;
            font-weight: 600;
            padding: 6px 12px;
            margin: 4px auto;
            background: rgba(255,149,0,0.08);
            border-radius: 16px;
            display: inline-block;
            max-width: 80%;
        }
        .nudge-message-wrapper {
            text-align: center;
            width: 100%;
        }

        /* Uppercase para nickname y canal */
        #name-input, #channel-input {
            text-transform: uppercase;
        }
        #name-input::placeholder, #channel-input::placeholder {
            text-transform: none;
        }

        /* Botón de ayuda - MUY pequeño */
        #name-prompt .help-btn {
            background: none;
            border: 1px solid rgba(0,122,255,0.2);
            color: #5a9fff;
            padding: 2px 7px;
            border-radius: 4px;
            font-size: 0.6em;
            font-weight: 400;
            cursor: pointer;
            margin-top: 0;
            transition: all 0.2s;
        }
        #name-prompt .help-btn:hover {
            background: rgba(0,122,255,0.06);
        }

        /* Modal de ayuda */
        .help-modal-body {
            text-align: left;
            font-size: 0.9em;
            line-height: 1.6;
            color: #333;
            max-height: 60vh;
            overflow-y: auto;
            padding: 10px 0;
        }
        .help-modal-body h3 {
            color: #007aff;
            margin: 14px 0 6px 0;
            font-size: 1em;
        }
        .help-modal-body h3:first-child {
            margin-top: 0;
        }
        .help-modal-body p {
            margin: 4px 0 10px 0;
        }

        /* Aprobación pendiente */
        .approval-pending-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.7);
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            gap: 16px;
            color: white;
        }
        .approval-pending-overlay .spinner {
            width: 48px; height: 48px;
            border: 4px solid rgba(255,255,255,0.3);
            border-top-color: #007aff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .approval-pending-overlay h2 {
            font-size: 1.3em;
            margin: 0;
        }
        .approval-pending-overlay p {
            font-size: 0.9em;
            opacity: 0.8;
            margin: 0;
        }
        .approval-pending-overlay button {
            padding: 10px 24px;
            background: #ff3b30;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            margin-top: 10px;
        }

        /* Solicitudes pendientes en chat */
        .pending-request {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 10px;
            padding: 10px 14px;
            margin: 6px 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            font-size: 0.88em;
        }
        .pending-request .pr-name {
            font-weight: 600;
            color: #856404;
        }
        .pending-request .pr-actions {
            display: flex;
            gap: 6px;
        }
        .pending-request .pr-btn {
            padding: 4px 10px;
            border: none;
            border-radius: 6px;
            font-size: 0.82em;
            cursor: pointer;
            font-weight: 600;
        }
        .pending-request .pr-approve {
            background: #28a745;
            color: white;
        }
        .pending-request .pr-reject {
            background: #dc3545;
            color: white;
        }

        /* Lightbox para visualizar imágenes */
        #image-lightbox {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            z-index: 10000;
            background: rgba(0,0,0,0.92);
            align-items: center;
            justify-content: center;
            flex-direction: column;
            cursor: zoom-out;
            -webkit-backdrop-filter: blur(8px);
            backdrop-filter: blur(8px);
        }
        #image-lightbox.active { display: flex; }
        #image-lightbox img {
            max-width: 92vw;
            max-height: 85vh;
            object-fit: contain;
            border-radius: 8px;
            box-shadow: 0 8px 40px rgba(0,0,0,0.5);
            user-select: none;
            -webkit-user-select: none;
        }
        #image-lightbox .lightbox-close {
            position: absolute;
            top: 16px; right: 18px;
            background: rgba(255,255,255,0.15);
            border: none;
            color: #fff;
            font-size: 1.6em;
            width: 40px; height: 40px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10001;
        }
        #image-lightbox .lightbox-close:hover { background: rgba(255,255,255,0.3); }
        #image-lightbox .lightbox-download {
            margin-top: 14px;
            background: rgba(255,255,255,0.15);
            border: none;
            color: #fff;
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 0.9em;
            cursor: pointer;
        }
        #image-lightbox .lightbox-download:hover { background: rgba(255,255,255,0.3); }

        #ichat-description {
            margin-top: 14px;
            padding: 16px 18px;
            background: rgba(255,255,255,0.85);
            border-radius: 14px;
            max-width: 420px;
            width: 100%;
            text-align: left;
            box-shadow: 0 1px 6px rgba(0,0,0,0.06);
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            flex: 1 1 auto;
            min-height: 0;
        }

        .share-link-card {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 12px 12px;
            border-radius: 12px;
            background: rgba(0,122,255,0.08);
            border: 1px solid rgba(0,122,255,0.12);
            margin-bottom: 12px;
        }
        .share-link-title {
            font-weight: 800;
            color: #0a2a5a;
            font-size: 0.95em;
            line-height: 1.25;
        }
        .share-link-row {
            display: flex;
            align-items: center;
            gap: 10px;
            justify-content: space-between;
        }
        .share-link-url {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 0.85em;
            color: #003a8c;
            background: rgba(255,255,255,0.75);
            padding: 8px 10px;
            border-radius: 10px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex: 1;
            border: 1px solid rgba(0,0,0,0.05);
        }
        .share-link-actions {
            display: flex;
            gap: 8px;
        }
        .share-link-card .share-btn {
            border: none;
            background: rgba(0,122,255,0.1);
            color: #3d7ec7;
            padding: 1px 5px;
            border-radius: 3px;
            font-size: 0.6em;
            font-weight: 400;
            cursor: pointer;
            transition: background 0.2s ease;
        }
        .share-btn:hover { background: rgba(0,122,255,0.25); }
        .share-hint {
            margin: 0;
            font-size: 0.82em;
            color: rgba(0,0,0,0.55);
            line-height: 1.35;
        }

        /* Estilos para el encabezado del chat */
        #chat-header {
            display: flex;
            justify-content: space-between; /* Espacio entre título/online y botón de settings */
            align-items: center;
            padding: 0 20px 10px 20px; /* Padding superior, sin padding lateral extra */
            flex-shrink: 0;
            position: relative; /* Para posicionar el dropdown */
        }

         #chat-header h2 {
             margin: 0;
             font-size: 1.3em;
             color: #1c1c1e;
         }

        /* Ajustes finos para escritorio (mantener móvil intacto) */
        @media (min-width: 769px) {
            #bottom-fixed-area {
                bottom: 20px; /* Alinea visualmente con el padding del body */
            }
        }

         #online-users {
             font-size: 0.9em;
             color: #8e8e93;
             margin-top: 5px;
             min-height: 1.2em; /* Reserva espacio */
         }


        /* Estilos para la caja de chat (mensajes) */
        #chat-box {
            flex-grow: 1; /* Permite que la caja de chat ocupe el espacio restante */
            padding: 0 20px; /* Padding lateral */
            overflow-y: auto; /* Habilita el scroll vertical si los mensajes exceden la altura */
            border-bottom: 1px solid #eee;
            display: flex;
            flex-direction: column;
            gap: 12px; /* Más espacio entre mensajes */

            /* Estilos para la imagen de fondo */
            background-image: url('https://images.unsplash.com/photo-1518655048521-f130df041722?q=80&w=2070&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D'); /* URL de imagen de fondo moderna y sobria */
            background-size: cover; /* Cubrir el área del contenedor */
            background-position: center; /* Centrar la imagen */
            background-repeat: no-repeat; /* No repetir la imagen */
             /* Padding inferior dinámico ajustado por JS */
            padding-bottom: 20px; /* Padding inicial, se ajustará con JS */
        }

        /* Estilos para cada mensaje individual */
        .message {
            padding: 12px 18px; /* Aumentar padding del mensaje */
            border-radius: 18px; /* Bordes más redondeados */
            max-width: 85%; /* Aumentar ancho máximo */
            word-wrap: break-word;
            position: relative;
            line-height: 1.5; /* Mejorar espaciado entre líneas */
            font-size: 1.1em; /* Aumentar tamaño de fuente base del mensaje */
            /* Añadir un fondo semi-transparente para que el texto sea legible sobre la imagen */
            background-color: rgba(255, 255, 255, 0.9); /* Blanco con 90% de opacidad */
            cursor: pointer; /* Indicar que se puede hacer clic para responder */
            display: flex; /* Usar flexbox para organizar el contenido interno */
            flex-direction: column; /* Apilar nombre, respuesta, y footer */
            z-index: 1; /* Asegurar que los mensajes estén por encima */
        }

        .message .name {
             font-size: 0.9em; /* Tamaño de fuente del nombre (relativo al 1.1em del mensaje) */
             color: #3a3a3c; /* Color de texto sutil */
             margin-bottom: 2px; /* Espacio debajo del nombre */
             display: block;
             font-weight: 600; /* Semi-negrita */
        }

        .message .text {
            display: block;
            font-size: 1em; /* Tamaño de fuente del texto (relativo al 1.1em del mensaje) */
            /* margin-bottom: 4px; Eliminado, el margen ahora está en el footer */
             flex-grow: 1; /* Permitir que el texto ocupe espacio */
             min-width: 0; /* Permitir que el texto se encoja y envuelva */
             margin-right: auto; /* Empujar la hora/checks a la derecha */
             padding-right: 8px; /* Espacio entre texto y hora/checks */
             /* Asegurar que el texto se envuelva correctamente */
             overflow-wrap: break-word;
             word-break: break-word;
        }

         /* Estilos para los enlaces dentro de los mensajes */
        .message a {
            color: #007aff; /* Color azul para enlaces */
            text-decoration: none; /* Sin subrayado por defecto */
        }

        .message a:hover {
            text-decoration: underline; /* Subrayado al pasar el ratón */
        }


         /* Contenedor para texto, hora y checkmarks */
         .message-footer {
             display: flex;
             align-items: center; /* Alinear verticalmente */
             justify-content: flex-end; /* Alinear a la derecha */
             flex-wrap: wrap; /* Permitir que los elementos se envuelvan si no hay espacio */
             /* gap: 5px; */ /* Espacio entre elementos del footer */
             margin-top: 4px; /* Espacio arriba del footer */
         }


        .message .timestamp {
            font-size: 0.7em; /* Tamaño de fuente de la hora (relativo al 1.1em del mensaje) */
            color: #8e8e93; /* Gris tenue */
            /* text-align: right; Eliminado, manejado por flexbox */
            display: inline-block; /* O inline, ambos funcionan con flexbox */
             /* margin-top: 4px; Eliminado, el margen está en el footer */
             flex-shrink: 0; /* Evitar que se encoja */
             margin-left: 4px; /* Espacio a la izquierda del timestamp */
        }

         /* Estilos para los checkmarks */
         .message .checkmarks {
             font-size: 0.8em; /* Tamaño de los checkmarks */
             color: #007aff; /* Color azul para checkmarks */
             margin-left: 4px; /* Espacio a la izquierda */
             vertical-align: middle; /* Alinear verticalmente */
             display: inline; /* O inline-block */
             flex-shrink: 0; /* Evitar que se encoja */
         }

         .edited-label {
             font-size: 0.65em;
             color: #8e8e93;
             font-style: italic;
             margin-right: 4px;
             flex-shrink: 0;
         }

         .msg-actions-menu {
             position: fixed;
             background: #fff;
             border-radius: 12px;
             box-shadow: 0 4px 20px rgba(0,0,0,0.22);
             z-index: 9999;
             overflow: hidden;
             min-width: 160px;
         }
         .msg-actions-menu button {
             display: block;
             width: 100%;
             padding: 11px 16px;
             border: none;
             background: none;
             text-align: left;
             font-size: 0.9em;
             cursor: pointer;
             font-family: inherit;
         }
         .msg-actions-menu button:hover {
             background: #f2f2f7;
         }
         .msg-actions-menu button:not(:last-child) {
             border-bottom: 1px solid #e5e5ea;
         }
         .msg-actions-menu .delete-action {
             color: #ff3b30;
         }


        /* Estilos para mensajes recibidos */
        .message.received {
            background-color: rgba(229, 229, 234, 0.9); /* Gris claro con 90% de opacidad */
            align-self: flex-start;
            border-bottom-left-radius: 5px; /* Esquina inferior izquierda menos redondeada */
        }

        /* Estilos para mensajes enviados */
        .message.sent {
            background-color: rgba(0, 122, 255, 0.9); /* Azul con 90% de opacidad */
            color: white; /* Texto blanco */
            align-self: flex-end;
            border-bottom-right-radius: 5px; /* Esquina inferior derecha menos redondeada */
        }

         /* Estilos para mensajes enviados - elementos internos */
        .message.sent .name,
        .message.sent .text,
        .message.sent .timestamp {
            /* color: white !important; Removido para probar inline style */
            color: inherit;
        }
         .message.sent .timestamp {
             /* color: rgba(255, 255, 255, 0.8) !important; Removido para probar inline style */
             color: inherit;
         }
         .message.sent .checkmarks {
             color: white !important; /* Checkmarks blancos en mensajes enviados, forzar */
         }

        /* Estilos para el contenedor del video de YouTube y otros embeds */
        .video-preview-container {
            margin-top: 8px; /* Espacio entre el texto y el video */
            margin-bottom: 4px; /* Espacio entre el video y el footer */
            width: 100%; /* Ocupar el ancho del mensaje */
            aspect-ratio: 16 / 9; /* Mantener relación de aspecto 16:9 */
            overflow: hidden; /* Asegurar que el iframe o video no se salga */
            border-radius: 8px; /* Bordes redondeados para la previsualización */
        }

        .video-preview-container iframe,
        .video-preview-container video {
            width: 100%;
            height: 100%;
            border: none; /* Eliminar borde */
        }


        /* Contenedor fijo para el área de input y el indicador de escribiendo */
        #bottom-fixed-area {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            width: 100%;
            max-width: 700px;
            box-sizing: border-box;
            margin: 0 auto;
            z-index: 5;
            display: flex;
            flex-direction: column;
            background: rgba(255,255,255,0.85);
            -webkit-backdrop-filter: blur(16px);
            backdrop-filter: blur(16px);
            border-top: 1px solid rgba(0,0,0,0.06);
            padding: 6px 14px 10px;
        }

        /* --- Debugging Styles for typing indicator --- */
        #typing-indicator {
            font-size: 0.9em; /* Aumentar tamaño */
            color: #8e8e93; /* Gris tenue */
            padding: 0 5px; /* Padding interno */
            min-height: 1.2em; /* Reserva espacio */
            text-align: right; /* Alinear a la derecha */
            margin-bottom: 5px; /* Añadir margen debajo del indicador */
            /* border: 1px dashed blue; Debugging border */
            /* background-color: rgba(0, 0, 255, 0.1); Debugging background */
        }
        /* --- End Debugging Styles --- */


        /* ========== MEDIA TOOLBAR (entre chat e input) ========== */
        .media-toolbar {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 4px 6px;
        }
        .media-btn {
            width: 36px;
            height: 36px;
            border: none;
            border-radius: 50%;
            background: transparent;
            color: #007aff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s, transform 0.15s;
            -webkit-tap-highlight-color: transparent;
        }
        .media-btn:hover { background: rgba(0,122,255,0.08); }
        .media-btn:active { transform: scale(0.9); }
        .media-btn svg { width: 21px; height: 21px; }
        #mic-button.recording {
            background: #ff3b30 !important;
            color: white !important;
            animation: pulse-rec 1s infinite;
        }
        #mic-button.recording svg { stroke: white; }

        /* ========== INPUT BAR — iMessage Style ========== */
        .message-input-area {
            display: flex;
            align-items: flex-end;
            gap: 8px;
            padding: 0 4px 2px;
            flex-shrink: 0;
        }

        .message-input-area textarea {
            flex: 1;
            padding: 10px 16px;
            border: 1.5px solid #e0e0e5;
            border-radius: 22px;
            font-size: 1em;
            font-family: inherit;
            box-sizing: border-box;
            outline: none;
            background: #f9f9fb;
            transition: border-color 0.25s, box-shadow 0.25s;
            line-height: 1.45;
            resize: none;
            min-height: 42px;
            max-height: 120px;
            overflow-y: auto;
            color: #1c1c1e;
        }
        .message-input-area textarea::placeholder {
            color: #b0b0b8;
        }
        .message-input-area textarea:focus {
            border-color: #007aff;
            box-shadow: 0 0 0 3px rgba(0,122,255,0.10);
            background: #fff;
        }

        /* Icon buttons inside input bar */
        .input-icon-btn {
            width: 38px;
            height: 38px;
            border: none;
            border-radius: 50%;
            background: transparent;
            color: #8e8e93;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            transition: background 0.2s, color 0.2s;
            -webkit-tap-highlight-color: transparent;
        }
        .input-icon-btn:hover { background: rgba(0,0,0,0.04); color: #3a3a3c; }
        .input-icon-btn:active { transform: scale(0.92); }
        .input-icon-btn svg { width: 22px; height: 22px; }

        /* Send button */
        #send-button {
            width: 38px;
            height: 38px;
            border: none;
            border-radius: 50%;
            background: #007aff;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            transition: background 0.2s, transform 0.15s;
            -webkit-tap-highlight-color: transparent;
            box-shadow: 0 2px 8px rgba(0,122,255,0.25);
        }
        #send-button:hover { background: #0062d1; }
        #send-button:active { transform: scale(0.9); }
        #send-button svg { width: 18px; height: 18px; margin-left: 2px; }

        #emoji-button svg { stroke: #8e8e93; }
        #emoji-button:hover svg { stroke: #3a3a3c; }

        /* Estilos para el botón de limpiar chat */
        /* Ahora dentro del dropdown */
        #settings-dropdown button { /* Aplicar a todos los botones dentro del dropdown */
            padding: 10px 15px; /* Padding para elemento de menú */
            background-color: transparent; /* Fondo transparente */
            color: #1c1c1e; /* Color de texto oscuro */
            border: none;
            border-radius: 0; /* Sin bordes redondeados */
            cursor: pointer;
            font-size: 1em; /* Tamaño de fuente estándar */
            margin: 0; /* Sin margen */
            width: 100%; /* Ocupar todo el ancho del dropdown */
            text-align: left; /* Alinear texto a la izquierda */
            transition: background-color 0.1s ease-in-out;
            display: block; /* Asegurar que sea un bloque para ocupar el ancho */
        }

        #settings-dropdown button:hover { /* Aplicar a todos los botones al pasar el ratón */
            background-color: #e5e5ea; /* Fondo gris claro al pasar el ratón */
        }

        /* Estilo específico para el botón de limpiar chat al pasar el ratón */
        #settings-dropdown #clear-chat-button:hover {
             color: #ff3b30; /* Color rojo al pasar el ratón */
        }


        /* Oculta la interfaz de chat inicialmente */
        #chat-interface {
            display: none;
            flex-direction: column;
            flex-grow: 1; /* Asegura que la interfaz de chat ocupe el espacio disponible */
             /* Ajuste clave: Darle una altura al contenedor flex para que los hijos flex-grow funcionen */
            height: 100%;
            position: relative; /* Necesario para posicionar el selector de emojis si se pone fuera del input-area */
        }

        /* Estilos para el selector de emojis */
        #emoji-picker {
            display: none; /* Oculto por defecto */
            position: absolute;
            /* bottom se ajusta dinámicamente en JS */
            left: 20px; /* Alinear a la izquierda */
            background-color: #fff;
            border: 1px solid #d1d1d6;
            border-radius: 8px;
            padding: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            z-index: 10; /* Asegurar que esté por encima de otros elementos */
            max-height: 200px; /* Altura máxima para scroll */
            overflow-y: auto; /* Habilitar scroll si hay muchos emojis */
            width: calc(100% - 40px); /* Ocupar el ancho del contenedor con padding */
            box-sizing: border-box;
            flex-wrap: wrap; /* Permite que los emojis se envuelvan */
            gap: 5px; /* Espacio entre emojis */
        }

        #emoji-picker span {
            cursor: pointer;
            font-size: 1.5em; /* Tamaño de los emojis */
            padding: 3px;
            border-radius: 4px;
            transition: background-color 0.1s ease-in-out;
        }

        #emoji-picker span:hover {
            background-color: #e5e5ea;
        }

        /* Estilos para la vista previa del mensaje al editar */
        #edit-preview {
            display: none;
            background-color: #fff9e6;
            border-left: 4px solid #ff9500;
            padding: 10px 15px;
            border-radius: 8px;
            margin-bottom: 10px;
            width: 100%;
            box-sizing: border-box;
            position: relative;
        }
        #edit-preview .edit-label {
            font-size: 0.85em;
            color: #ff9500;
            font-weight: 600;
            margin-bottom: 2px;
            display: block;
        }
        #edit-preview .edit-text {
            font-size: 0.95em;
            color: #1c1c1e;
            display: block;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        #edit-preview #cancel-edit-button {
            position: absolute;
            top: 5px;
            right: 5px;
            background: none;
            border: none;
            cursor: pointer;
            padding: 0;
            width: 20px;
            height: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #8e8e93;
            font-size: 1.2em;
        }
        #edit-preview #cancel-edit-button:hover {
            color: #3a3a3c;
        }
        @media (max-width: 768px) {
            #edit-preview {
                padding: 8px 10px;
            }
        }

        /* Estilos para la vista previa del mensaje al responder */
        #reply-preview {
            display: none; /* Oculto por defecto */
            background-color: #e5e5ea; /* Fondo gris claro */
            border-left: 4px solid #007aff; /* Barra azul a la izquierda */
            padding: 10px 15px;
            border-radius: 8px;
            margin-bottom: 10px; /* Espacio debajo de la vista previa */
            width: 100%; /* Ocupar todo el ancho */
            box-sizing: border-box;
            position: relative; /* Para posicionar el botón de cerrar */
        }

        #reply-preview .reply-name {
            font-size: 0.9em;
            color: #3a3a3c;
            font-weight: 600;
            margin-bottom: 2px;
            display: block;
        }

        #reply-preview .reply-text {
            font-size: 1em;
            color: #1c1c1e;
            display: block;
            /* Limitar el texto para que no sea demasiado largo */
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        #reply-preview #cancel-reply-button {
            position: absolute;
            top: 5px;
            right: 5px;
            background: none;
            border: none;
            cursor: pointer;
            padding: 0;
            width: 20px;
            height: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #8e8e93; /* Color gris */
            font-size: 1.2em;
        }

        #reply-preview #cancel-reply-button:hover {
            color: #3a3a3c; /* Gris más oscuro al pasar el ratón */
        }

        /* Estilos para mostrar el contenido de la respuesta dentro de un mensaje */
        .message .reply-content {
            background-color: rgba(0, 0, 0, 0.05); /* Fondo ligeramente oscuro */
            border-left: 4px solid rgba(0, 122, 255, 0.5); /* Barra azul semi-transparente */
            padding: 8px 12px;
            border-radius: 6px;
            margin-bottom: 8px; /* Espacio debajo del contenido de respuesta */
            font-size: 0.9em; /* Tamaño de fuente más pequeño */
            word-wrap: break-word;
        }

        .message.sent .reply-content {
             border-left-color: rgba(255, 255, 255, 0.5); /* Barra blanca semi-transparente en mensajes enviados */
        }


        .message .reply-content .reply-name {
            font-weight: 600;
            margin-bottom: 2px;
            display: block;
            color: #3a3a3c; /* Color de texto sutil */
        }
         .message.sent .reply-content .reply-name {
             color: rgba(255, 255, 255, 0.8); /* Color de texto sutil en mensajes enviados */
         }


        .message .reply-content .reply-text {
            display: block;
            color: #1c1c1e; /* Texto oscuro */
            /* Limitar el texto para que no sea demasiado largo */
             white-space: nowrap;
             overflow: hidden;
             text-overflow: ellipsis;
        }
         .message.sent .reply-content .reply-text {
             color: white; /* Texto blanco en mensajes enviados */
         }


        /* Estilos para el menú desplegable de configuración */
        #settings-dropdown {
            display: none; /* Oculto por defecto */
            position: absolute;
            /* bottom y right se ajustan dinámicamente en JS o se calculan */
            background-color: #fff;
            border: 1px solid #d1d1d6;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            z-index: 10; /* Asegurar que esté por encima de otros elementos */
            min-width: 150px; /* Ancho mínimo del menú */
            padding: 5px 0; /* Padding interno */
            flex-direction: column; /* Elementos apilados verticalmente */
            top: 40px; /* Posicionar debajo del botón de settings */
            right: 20px; /* Alinear a la derecha del chat-header */
        }


        /* Media query para pantallas más pequeñas (Android) */
        @media (max-width: 768px) {
            body {
                padding: 0; /* Eliminar padding del body en móviles */
                display: block;
            }
            #chat-container {
                max-width: 100vw; /* Ocupar todo el ancho del viewport */
                border-radius: 0; /* Eliminar bordes redondeados en pantalla completa */
                 padding: 0; /* Eliminar padding del contenedor en móviles */
                 height: 100vh;
                 max-height: 100vh;
            }

            #name-prompt {
                padding: 20px 15px;
            }

            #name-prompt input {
                font-size: 1em;
                padding: 10px 12px;
            }

             #name-prompt input[type="text"] { /* Especificar input de texto */
                 align-self: center;
                 width: 90%;
                 max-width: 300px;
             }

             /* Contenedor fijo para el área de input y el indicador de escribiendo en móviles */
             #bottom-fixed-area {
                 max-width: 100vw;
                 padding: 10px 15px; /* Ajustar padding para móviles */
                 bottom: 0;
             }


             .message-input-area {
                 gap: 6px;
                 padding: 0 2px 2px;
             }

             .message-input-area textarea {
                 font-size: 0.95em;
                 padding: 9px 14px;
                 min-height: 38px;
                 max-height: 100px;
             }

             .media-toolbar {
                 padding: 2px 4px;
                 gap: 2px;
             }
             .media-btn { width: 34px; height: 34px; }
             .input-icon-btn { width: 34px; height: 34px; }
             #send-button { width: 36px; height: 36px; }
             #send-button svg { width: 16px; height: 16px; }

             #settings-button {
                 /* Ajuste de tamaño y posición para móviles */
                 width: 40px;
                 height: 40px;
                 padding: 0;
                 align-self: center;
                 font-size: 1.5em; /* Tamaño para el emoji */
                 /* Añadido para intentar centrar el emoji */
                 line-height: 1;
                 vertical-align: middle;
             }

             #settings-dropdown button { /* Aplicar a todos los botones dentro del dropdown */
                 font-size: 0.9em;
                 padding: 8px 12px;
             }

             .message {
                 max-width: 90%; /* Permitir que los mensajes ocupen más ancho */
             }

             /* Ajuste del indicador de escribiendo en móviles */
             #typing-indicator {
                 /* align-self: flex-end; Eliminado */
                 /* margin-bottom: 5px; Eliminado */
                 padding: 0 5px; /* Ajustar padding lateral para móviles */
                 text-align: right; /* Asegurar alineación derecha */
                 margin-bottom: 5px; /* Añadir margen debajo del indicador */
             }

             /* Ajuste del selector de emojis en móviles */
             #emoji-picker {
                 /* bottom se ajustará dinámicamente en JS */
                 left: 10px;
                 width: calc(100% - 20px); /* Ajustar ancho para móviles */
             }

             /* Ajuste de la vista previa de respuesta en móviles */
             #reply-preview {
                 padding: 8px 10px;
             }

             /* Ajuste del dropdown de settings en móviles */
             #settings-dropdown {
                 top: 40px; /* Posicionar debajo del botón de settings */
                 right: 10px; /* Alinear a la derecha en móviles */
                 left: auto; /* Desactivar alineación izquierda */
             }

             /* Reducir tamaños generales en móvil */
             .message {
                 padding: 8px 12px;
                 border-radius: 14px;
                 font-size: 0.92em;
                 line-height: 1.35;
             }
             .message .name {
                 font-size: 0.8em;
                 margin-bottom: 1px;
             }
             .message .text {
                 font-size: 0.92em;
                 padding-right: 4px;
             }
             .message .timestamp {
                 font-size: 0.62em;
             }
             .message .checkmarks {
                 font-size: 0.7em;
             }
             .edited-label {
                 font-size: 0.58em;
             }
             #chat-box {
                 padding: 0 10px;
                 gap: 6px;
                 padding-bottom: 10px;
             }
             #chat-header {
                 padding: 0 12px 6px 12px;
             }
             #chat-header h2 {
                 font-size: 1.05em;
             }
             #online-users {
                 font-size: 0.75em;
             }
             .reply-bubble {
                 font-size: 0.8em !important;
                 padding: 4px 8px !important;
             }
        }

        /* Extra compacto para pantallas Android pequeñas */
        @media (max-width: 400px) {
             .message {
                 padding: 6px 10px;
                 font-size: 0.88em;
                 max-width: 92%;
             }
             #name-prompt h2 {
                 font-size: 1.15em;
             }
             #name-prompt input,
            #name-prompt button:not(#start-chat-button) {
                font-size: 0.9em;
                padding: 8px 10px;
            }

            #start-chat-button {
                padding: 14px 28px !important;
                font-size: 1.15em !important;
            }
             #bottom-fixed-area {
                 padding: 6px 10px;
             }
             .message-input-area textarea {
                 font-size: 0.9em;
                 padding: 6px 10px;
                 min-height: 36px;
             }
        }

        /* Ajuste para APK Android (WebView) - siempre respetar barra de estado */
        @media (max-width: 768px) {
            #chat-container {
                padding-top: env(safe-area-inset-top, 30px);
            }
        }
        .app-mode #chat-container {
            border-radius: 0;
            height: 100vh;
            max-height: 100vh;
            padding-top: env(safe-area-inset-top, 30px);
        }
        .app-mode body {
            padding: 0;
        }
        .app-mode #bottom-fixed-area {
            padding-bottom: calc(10px + env(safe-area-inset-bottom, 0px));
        }

         /* Header actions container */
         .header-actions {
             display: flex;
             align-items: center;
             gap: 2px;
         }
         .call-btn {
             width: 36px;
             height: 36px;
             padding: 0;
             display: flex;
             justify-content: center;
             align-items: center;
             background: transparent;
             border: none;
             border-radius: 50%;
             cursor: pointer;
             font-size: 1.2em;
             line-height: 1;
         }
         .call-btn:hover { background: #e5e5ea; }

         @keyframes pulse-rec {
             0%, 100% { transform: scale(1); }
             50% { transform: scale(1.15); }
         }

         /* Imagen en mensajes */
         .message-image {
             max-width: 100%;
             max-height: 250px;
             border-radius: 10px;
             cursor: pointer;
             margin: 4px 0;
         }
         .image-wrapper {
             position: relative;
             display: inline-block;
             max-width: 100%;
         }
         .image-expiry-badge {
             position: absolute;
             top: 6px;
             left: 6px;
             background: rgba(0,0,0,0.65);
             color: #ffd60a;
             font-size: 0.65em;
             padding: 2px 7px;
             border-radius: 8px;
             pointer-events: none;
         }
         .image-download-btn {
             position: absolute;
             bottom: 8px;
             right: 8px;
             background: rgba(0,0,0,0.55);
             color: white;
             border: none;
             border-radius: 50%;
             width: 32px;
             height: 32px;
             font-size: 1em;
             cursor: pointer;
             display: flex;
             align-items: center;
             justify-content: center;
         }
         .image-expired-placeholder {
             background: #e5e5ea;
             border-radius: 10px;
             padding: 20px;
             text-align: center;
             color: #8e8e93;
             font-size: 0.85em;
             margin: 4px 0;
         }
         /* Banner de subida de video */
         .upload-banner {
             position: fixed;
             top: 0;
             left: 50%;
             transform: translateX(-50%);
             max-width: 700px;
             width: 100%;
             background: linear-gradient(135deg, #007aff 0%, #5856d6 100%);
             color: white;
             padding: 10px 16px;
             display: flex;
             align-items: center;
             gap: 10px;
             z-index: 9998;
             font-size: 0.88em;
             font-weight: 500;
             box-shadow: 0 4px 16px rgba(0,0,0,0.2);
             animation: slideDown 0.3s ease;
         }
         .upload-banner .upload-spinner {
             width: 18px; height: 18px;
             border: 2.5px solid rgba(255,255,255,0.3);
             border-top-color: white;
             border-radius: 50%;
             animation: spin 0.8s linear infinite;
         }
         @keyframes slideDown {
             from { transform: translateX(-50%) translateY(-100%); }
             to { transform: translateX(-50%) translateY(0); }
         }

         /* Grabación de audio: botón cancelar */
         .audio-cancel-btn {
             width: 34px;
             height: 34px;
             border: none;
             border-radius: 50%;
             background: rgba(255,59,48,0.15);
             color: #ff3b30;
             cursor: pointer;
             display: none;
             align-items: center;
             justify-content: center;
             transition: background 0.2s;
             -webkit-tap-highlight-color: transparent;
         }
         .audio-cancel-btn.visible { display: flex; }
         .audio-cancel-btn:hover { background: rgba(255,59,48,0.25); }
         .audio-cancel-btn svg { width: 18px; height: 18px; }

         /* Audio speed button */
         .audio-speed-btn {
             border: none;
             background: rgba(0,0,0,0.08);
             color: inherit;
             padding: 1px 5px;
             border-radius: 4px;
             font-size: 0.65em;
             font-weight: 600;
             cursor: pointer;
             min-width: 28px;
             text-align: center;
             transition: background 0.15s;
             opacity: 0.7;
         }
         .audio-speed-btn:hover { opacity: 1; background: rgba(0,0,0,0.12); }
         .message.sent .audio-speed-btn {
             background: rgba(255,255,255,0.2);
             color: white;
         }
         .message.sent .audio-speed-btn:hover { background: rgba(255,255,255,0.3); }

         .toast-notification {
             position: fixed;
             bottom: 80px;
             left: 50%;
             transform: translateX(-50%);
             background: rgba(0,0,0,0.8);
             color: white;
             padding: 10px 20px;
             border-radius: 20px;
             font-size: 0.85em;
             z-index: 9999;
             opacity: 0;
             transition: opacity 0.3s;
             pointer-events: none;
             text-align: center;
             max-width: 90%;
         }
         .toast-notification.show { opacity: 1; }

         /* Video en mensajes */
         .message-video {
             max-width: 100%;
             max-height: 250px;
             border-radius: 10px;
             margin: 4px 0;
             background: #000;
         }
         .video-wrapper {
             position: relative;
             display: inline-block;
             max-width: 100%;
         }
         .video-wrapper .image-expiry-badge {
             top: 6px; left: 6px;
         }
         .video-wrapper .image-download-btn {
             top: 6px; right: 6px;
         }

         /* Documento en mensajes */
         .doc-attachment {
             display: flex;
             align-items: center;
             gap: 10px;
             padding: 10px 14px;
             border-radius: 12px;
             margin: 4px 0;
             min-width: 180px;
             max-width: 280px;
             cursor: pointer;
             transition: background 0.2s;
         }
         .message.received .doc-attachment {
             background: rgba(0,0,0,0.06);
         }
         .message.received .doc-attachment:hover {
             background: rgba(0,0,0,0.1);
         }
         .message.sent .doc-attachment {
             background: rgba(255,255,255,0.18);
         }
         .message.sent .doc-attachment:hover {
             background: rgba(255,255,255,0.25);
         }
         .doc-icon {
             width: 38px;
             height: 38px;
             min-width: 38px;
             border-radius: 10px;
             display: flex;
             align-items: center;
             justify-content: center;
             font-size: 1.4em;
         }
         .message.received .doc-icon { background: rgba(0,122,255,0.1); }
         .message.sent .doc-icon { background: rgba(255,255,255,0.2); }
         .doc-info {
             flex: 1;
             min-width: 0;
             display: flex;
             flex-direction: column;
             gap: 2px;
         }
         .doc-name {
             font-size: 0.88em;
             font-weight: 600;
             overflow: hidden;
             text-overflow: ellipsis;
             white-space: nowrap;
         }
         .doc-size {
             font-size: 0.72em;
             opacity: 0.65;
         }
         .doc-expired-placeholder {
             display: flex;
             align-items: center;
             gap: 8px;
             padding: 10px 14px;
             border-radius: 12px;
             background: rgba(0,0,0,0.05);
             color: #8e8e93;
             font-size: 0.85em;
             margin: 4px 0;
         }

         /* iOS Install Banner */
         .ios-install-banner {
             display: none;
             position: fixed;
             bottom: 0;
             left: 0;
             right: 0;
             background: white;
             border-radius: 20px 20px 0 0;
             box-shadow: 0 -4px 30px rgba(0,0,0,0.18);
             z-index: 10001;
             padding: 24px 20px 30px;
             animation: ios-slide-up 0.35s ease-out;
             max-width: 500px;
             margin: 0 auto;
         }
         .ios-install-banner.show { display: block; }
         @keyframes ios-slide-up {
             from { transform: translateY(100%); }
             to { transform: translateY(0); }
         }
         .ios-banner-header {
             display: flex;
             align-items: center;
             justify-content: space-between;
             margin-bottom: 16px;
         }
         .ios-banner-header h3 {
             margin: 0;
             font-size: 1.15em;
             color: #1c1c1e;
         }
         .ios-banner-close {
             width: 30px;
             height: 30px;
             border: none;
             background: #e5e5ea;
             border-radius: 50%;
             font-size: 1.1em;
             cursor: pointer;
             display: flex;
             align-items: center;
             justify-content: center;
             color: #8e8e93;
         }
         .ios-banner-steps {
             list-style: none;
             padding: 0;
             margin: 0;
             display: flex;
             flex-direction: column;
             gap: 14px;
         }
         .ios-banner-steps li {
             display: flex;
             align-items: center;
             gap: 12px;
             font-size: 0.95em;
             color: #3a3a3c;
         }
         .ios-step-icon {
             width: 40px;
             height: 40px;
             min-width: 40px;
             border-radius: 12px;
             background: #f2f2f7;
             display: flex;
             align-items: center;
             justify-content: center;
             font-size: 1.3em;
         }
         .ios-step-num {
             font-weight: 700;
             color: #007aff;
             margin-right: 4px;
         }
         .ios-install-backdrop {
             display: none;
             position: fixed;
             inset: 0;
             background: rgba(0,0,0,0.4);
             z-index: 10000;
         }
         .ios-install-backdrop.show { display: block; }

         /* Audio player custom en mensajes */
         .audio-player-custom {
             display: flex;
             align-items: center;
             gap: 10px;
             min-width: 200px;
             max-width: 300px;
             padding: 6px 4px;
             margin: 4px 0;
         }
         .audio-play-btn {
             width: 36px;
             height: 36px;
             min-width: 36px;
             border: none;
             border-radius: 50%;
             cursor: pointer;
             display: flex;
             align-items: center;
             justify-content: center;
             transition: transform 0.15s, background 0.2s;
             -webkit-tap-highlight-color: transparent;
         }
         .audio-play-btn:active { transform: scale(0.9); }
         /* Colores según contexto sent/received */
         .message.sent .audio-play-btn {
             background: rgba(255,255,255,0.25);
             color: white;
         }
         .message.sent .audio-play-btn:hover { background: rgba(255,255,255,0.35); }
         .message.received .audio-play-btn {
             background: rgba(0,122,255,0.12);
             color: #007aff;
         }
         .message.received .audio-play-btn:hover { background: rgba(0,122,255,0.2); }
         .audio-play-btn svg { width: 18px; height: 18px; }

         .audio-track {
             flex: 1;
             display: flex;
             flex-direction: column;
             gap: 3px;
             min-width: 0;
         }
         .audio-progress-bar {
             width: 100%;
             height: 4px;
             border-radius: 2px;
             cursor: pointer;
             appearance: none;
             -webkit-appearance: none;
             outline: none;
         }
         .message.sent .audio-progress-bar {
             background: rgba(255,255,255,0.25);
         }
         .message.sent .audio-progress-bar::-webkit-slider-thumb {
             -webkit-appearance: none;
             width: 12px; height: 12px;
             border-radius: 50%;
             background: white;
             cursor: pointer;
         }
         .message.sent .audio-progress-bar::-webkit-slider-runnable-track {
             height: 4px; border-radius: 2px;
         }
         .message.received .audio-progress-bar {
             background: rgba(0,0,0,0.1);
         }
         .message.received .audio-progress-bar::-webkit-slider-thumb {
             -webkit-appearance: none;
             width: 12px; height: 12px;
             border-radius: 50%;
             background: #007aff;
             cursor: pointer;
         }
         .message.received .audio-progress-bar::-webkit-slider-runnable-track {
             height: 4px; border-radius: 2px;
         }
         .audio-time {
             font-size: 0.7em;
             opacity: 0.75;
             font-variant-numeric: tabular-nums;
             white-space: nowrap;
         }

         /* Overlay de llamada */
         #call-overlay {
             display: none;
             position: fixed;
             top: 0; left: 0;
             width: 100%; height: 100%;
             background: rgba(0,0,0,0.92);
             z-index: 10000;
             flex-direction: column;
             justify-content: center;
             align-items: center;
             color: white;
             font-family: inherit;
         }
         #call-overlay.active { display: flex; }
         #call-overlay.minimized {
             display: flex;
             top: auto; left: auto;
             bottom: 90px; right: 12px;
             width: 150px; height: 180px;
             border-radius: 16px;
             background: rgba(0,0,0,0.88);
             box-shadow: 0 4px 20px rgba(0,0,0,0.5);
             cursor: pointer;
             z-index: 10000;
             overflow: hidden;
             transition: all 0.25s ease;
         }
         #call-overlay.minimized .call-status,
         #call-overlay.minimized .call-name,
         #call-overlay.minimized .call-actions,
         #call-overlay.minimized .call-video-grid,
         #call-overlay.minimized #minimize-call-btn { display: none !important; }
         #call-overlay.minimized .call-timer {
             position: absolute;
             bottom: 6px; left: 0; right: 0;
             text-align: center;
             font-size: 0.75em;
             margin: 0;
             z-index: 3;
             text-shadow: 0 1px 3px rgba(0,0,0,0.8);
         }
         #call-overlay.minimized .local-video {
             position: relative;
             top: 0; right: 0;
             width: 100%; height: 100%;
             border-radius: 16px;
             object-fit: cover;
         }
         #call-overlay.minimized .mini-expand-hint {
             display: flex;
         }
         .mini-expand-hint {
             display: none;
             position: absolute;
             top: 6px; right: 6px;
             background: rgba(255,255,255,0.25);
             color: white;
             border-radius: 50%;
             width: 28px; height: 28px;
             align-items: center;
             justify-content: center;
             font-size: 0.85em;
             z-index: 4;
             pointer-events: none;
         }
         #minimize-call-btn {
             position: absolute;
             top: 12px; left: 12px;
             background: rgba(255,255,255,0.2);
             border: none;
             color: white;
             width: 40px; height: 40px;
             border-radius: 50%;
             font-size: 1.2em;
             cursor: pointer;
             z-index: 5;
             display: flex;
             align-items: center;
             justify-content: center;
         }
         #minimize-call-btn:hover { background: rgba(255,255,255,0.35); }
         #call-overlay .call-status {
             font-size: 1.1em;
             margin-bottom: 8px;
             opacity: 0.8;
         }
         #call-overlay .call-name {
             font-size: 1.8em;
             font-weight: 700;
             margin-bottom: 30px;
         }
         #call-overlay .call-timer {
             font-size: 1.2em;
             margin-bottom: 30px;
             font-variant-numeric: tabular-nums;
         }
         #call-overlay video {
             width: 90%;
             max-width: 400px;
             max-height: 50vh;
             border-radius: 12px;
             margin-bottom: 20px;
             background: #111;
         }
         #call-overlay .remote-video { display: none; }
         #call-overlay .local-video {
             position: absolute;
             top: 40px; right: 16px;
             width: 100px;
             height: 140px;
             border-radius: 10px;
             z-index: 2;
             object-fit: cover;
         }
         .call-actions {
             display: flex;
             gap: 20px;
         }
         .call-actions button {
             width: 60px;
             height: 60px;
             border-radius: 50%;
             border: none;
             font-size: 1.5em;
             cursor: pointer;
             display: flex;
             justify-content: center;
             align-items: center;
         }
         .call-actions .end-call {
             background: #ff3b30;
             color: white;
         }
         .call-actions .accept-call {
             background: #34c759;
             color: white;
         }
         .call-actions .toggle-btn {
             background: rgba(255,255,255,0.2);
             color: white;
         }
         .call-actions .toggle-btn.off {
             background: rgba(255,255,255,0.5);
         }
         .call-actions .toggle-btn.speaker-on {
             background: #34c759;
         }
         .call-actions .toggle-btn.speaker-off {
             background: rgba(255,255,255,0.2);
         }
         #speaker-btn {
             display: none;
         }
         #call-overlay.voice-call #speaker-btn {
             display: flex;
         }
         #call-overlay.voice-call .local-video {
             display: none !important;
         }

         /* Selector de participantes para llamada */
         #call-selector-modal {
             display: none;
             position: fixed;
             inset: 0;
             background: rgba(0,0,0,0.4);
             z-index: 10001;
             align-items: center;
             justify-content: center;
             backdrop-filter: blur(4px);
         }
         #call-selector-modal.active { display: flex; }
         .call-selector-card {
             background: #fff;
             border-radius: 14px;
             padding: 24px;
             width: 90%;
             max-width: 340px;
             box-shadow: 0 8px 30px rgba(0,0,0,0.15);
         }
         .call-selector-card h3 {
             font-size: 1.1em;
             margin: 0 0 16px 0;
             color: #1c1c1e;
             text-align: center;
         }
         .call-selector-list {
             max-height: 250px;
             overflow-y: auto;
             display: flex;
             flex-direction: column;
             gap: 4px;
             margin-bottom: 16px;
         }
         .call-selector-item {
             display: flex;
             align-items: center;
             gap: 10px;
             padding: 10px 12px;
             border-radius: 8px;
             cursor: pointer;
             transition: background 0.15s;
             margin: 0;
         }
         .call-selector-item:hover { background: #f2f2f7; }
         .call-selector-item input[type="checkbox"] {
             width: 18px;
             height: 18px;
             accent-color: #007aff;
         }
         .call-selector-actions {
             display: flex;
             gap: 10px;
             justify-content: center;
         }
         .call-selector-actions button {
             padding: 10px 20px;
             border: none;
             border-radius: 10px;
             font-size: 0.95em;
             font-weight: 600;
             cursor: pointer;
         }
         .call-selector-cancel {
             background: #e5e5ea;
             color: #1c1c1e;
         }
         .call-selector-start {
             background: #34c759;
             color: white;
         }
         .call-selector-start:hover { background: #2db84e; }
         .call-no-users {
             text-align: center;
             padding: 20px;
             color: #8e8e93;
             font-size: 0.9em;
         }

         /* Video grid en llamada grupal */
         .call-video-grid {
             display: grid;
             gap: 8px;
             width: 90%;
             max-width: 600px;
             max-height: 55vh;
             margin-bottom: 16px;
         }
         .call-video-grid.grid-1 { grid-template-columns: 1fr; }
         .call-video-grid.grid-2 { grid-template-columns: 1fr 1fr; }
         .call-video-grid.grid-3,
         .call-video-grid.grid-4 { grid-template-columns: 1fr 1fr; }
         .call-video-grid.grid-5,
         .call-video-grid.grid-6 { grid-template-columns: 1fr 1fr 1fr; }
         .call-video-cell {
             position: relative;
             border-radius: 12px;
             overflow: hidden;
             background: #222;
             aspect-ratio: 4/3;
         }
         .call-video-cell video {
             width: 100%;
             height: 100%;
             object-fit: cover;
         }
         .call-video-cell .video-label {
             position: absolute;
             bottom: 4px;
             left: 4px;
             background: rgba(0,0,0,0.6);
             color: white;
             font-size: 0.7em;
             padding: 2px 6px;
             border-radius: 4px;
         }

         /* Estilos para el botón de configuración en general */
         #settings-button {
             /* Ajuste de tamaño y posición */
             width: 40px;
             height: 40px;
             padding: 0;
             display: flex;
             justify-content: center;
             align-items: center;
             background-color: transparent; /* Fondo transparente */
             border: none;
             border-radius: 50%; /* Botón redondo */
             cursor: pointer;
             font-size: 1.5em; /* Tamaño para el emoji */
             color: #1c1c1e; /* Color oscuro para el emoji */
             /* Añadido para intentar centrar el emoji */
             line-height: 1;
             vertical-align: middle;
         }

         #settings-button:hover {
             background-color: #e5e5ea; /* Fondo gris claro al pasar el ratón */
         }


        /* Lock Overlay */
        #lock-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: #fff;
            z-index: 500;
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }
        #lock-overlay.active { display: flex; }
        .lock-content { text-align: center; padding: 40px; }
        .lock-icon { font-size: 64px; margin-bottom: 16px; }
        .lock-content h2 { font-size: 1.6em; color: #1c1c1e; margin-bottom: 8px; }
        .lock-content p { font-size: 1em; color: #8e8e93; margin-bottom: 28px; }
        .lock-buttons { display: flex; gap: 12px; justify-content: center; }
        .lock-btn { padding: 12px 24px; border: none; border-radius: 10px; font-size: 1em; font-weight: 600; cursor: pointer; transition: background-color .2s; }
        .lock-btn.primary { background-color: #007aff; color: #fff; }
        .lock-btn.primary:hover { background-color: #0056b3; }
        .lock-btn.secondary { background-color: #e5e5ea; color: #1c1c1e; }
        .lock-btn.secondary:hover { background-color: #d1d1d6; }

        /* Password / Prompt / Confirm Modal */
        #password-modal, #prompt-modal, #confirm-modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,.4);
            z-index: 600;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(4px);
        }
        #password-modal.active, #prompt-modal.active, #confirm-modal.active { display: flex; }
        .pw-modal-card {
            background: #fff;
            border-radius: 14px;
            padding: 28px 32px;
            width: 90%;
            max-width: 340px;
            box-shadow: 0 8px 30px rgba(0,0,0,.15);
            text-align: center;
        }
        .pw-modal-card h3 { font-size: 1.2em; color: #1c1c1e; margin-bottom: 16px; }
        #confirm-modal-message { margin: 0 0 16px 0; color: #3a3a3c; font-size: 0.95em; line-height: 1.45; }
        .pw-modal-card input {
            width: 100%; padding: 10px 14px; border: 1px solid #d1d1d6; border-radius: 8px;
            font-size: 1em; box-sizing: border-box; outline: none; margin-bottom: 8px;
        }
        .pw-modal-card input:focus { border-color: #007aff; box-shadow: 0 0 0 3px rgba(0,122,255,.12); }
        #pw-modal-error { font-size: .85em; color: #ff3b30; min-height: 1.2em; margin-bottom: 12px; }
        .pw-modal-actions { display: flex; gap: 10px; justify-content: center; }

    </style>

    <script src="https://www.gstatic.com/firebasejs/9.1.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.1.1/firebase-database-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.1.1/firebase-analytics-compat.js"></script>

</head>
<body>

    <div id="chat-container">
        <div id="name-prompt">
            <h2>Bienvenido a Ichat<span style="color:#007aff">msn</span></h2>
            <input type="text" id="name-input" placeholder="Tu nickname">
            <input type="text" id="channel-input" placeholder="Canal (ej: EQUIPO2026)" style="text-transform:uppercase;">
            <button id="start-chat-button">Entrar al Chat</button>
            <button class="help-btn" id="help-btn" type="button">❓ ¿Cómo funciona iChat?</button>
            <div id="ichat-description">
                <div class="share-link-card">
                    <div class="share-link-title">Comparte Ichatmsn con tus amigos</div>
                    <div class="share-link-row">
                        <div class="share-link-url" id="share-link-url">www.tinyurl.com/ichatmsn</div>
                        <div class="share-link-actions">
                            <button class="share-btn" id="copy-link-btn" type="button" title="Copiar link">Copiar</button>
                            <button class="share-btn" id="share-link-btn" type="button" title="Compartir">Compartir</button>
                        </div>
                    </div>
                    <p class="share-hint">Pásalo por WhatsApp o redes y arma tu canal privado en segundos.</p>
                </div>
                <p style="font-size:1.1em;font-weight:700;margin:0 0 6px 0;">Privacidad moderna con un toque retro 🗨️✨</p>
                <p style="margin:0 0 10px 0;color:#555;font-size:0.88em;line-height:1.5;">
                    Compatible con <b>Android</b>, <b>iPhone</b>, <b>PC</b> y <b>Tablets</b>. Entra desde cualquier dispositivo y sigue la conversación donde estés.
                </p>
                <p style="margin:0 0 8px 0;color:#555;font-size:0.88em;line-height:1.5;">
                    Olvídate de dar tu número. Aquí solo necesitas un <b>Nickname</b> y un <b>Canal</b>.<br>
                    ¿Canal nuevo? Créalo con un PIN. ¿Ya existe? Ingresa la clave y únete.
                </p>
                <p style="margin:0;color:#555;font-size:0.88em;line-height:1.5;">
                    📞 Llamadas · 📹 Videollamadas · 📎 Multimedia · 💬 Zumbidos<br>
                    Todo el poder moderno con la nostalgia del clásico Messenger.
                </p>
                <p style="margin:8px 0 0 0;font-size:0.82em;color:#007aff;font-weight:600;">Privado, divertido y sin complicaciones 🔒🚀</p>
            </div>
        </div>

        <div id="chat-interface">
            <div id="chat-header">
                 <div>
                     <h2 id="chat-title">iChat</h2>
                     <div id="online-users"></div> </div>
                 <div class="header-actions">
                     <button id="voice-call-button" class="call-btn" title="Llamada de voz">📞</button>
                     <button id="video-call-button" class="call-btn" title="Videollamada">📹</button>
                     <button id="settings-button" title="Configuración">
                          ⚙️
                     </button>
                 </div>
                 <div id="settings-dropdown">
                     <button id="lock-chat-button">🔒 Bloqueo</button>
                     <button id="clear-chat-button">Limpiar Chat</button>
                     <button id="change-name-button">Cambiar Nombre</button>
                     <button id="change-pin-button">🔑 Cambiar PIN</button>
                     <button id="change-channel-button">📡 Cambiar Canal</button>
                     <button id="owner-options-button">🛡️ Más opciones</button>
                     <button id="install-app-button" style="display:none">📲 Instalar App</button>
                 </div>
            </div>
             <div id="chat-box">
                </div>
            <div id="bottom-fixed-area">
                <div id="typing-indicator"></div>
                 <div id="emoji-picker">
                     </div>
                 <div id="reply-preview">
                    <span class="reply-name"></span>
                    <span class="reply-text"></span>
                    <button id="cancel-reply-button">×</button>
                </div>
                <div id="edit-preview">
                    <span class="edit-label">✏️ Editando mensaje</span>
                    <span class="edit-text"></span>
                    <button id="cancel-edit-button">×</button>
                </div>
                <div class="media-toolbar">
                    <input type="file" id="image-input" accept="image/*" style="display:none">
                    <input type="file" id="video-input" accept="video/*" style="display:none">
                    <input type="file" id="doc-input" accept=".pdf,.doc,.docx,.xls,.xlsx,.ppt,.pptx,.txt,.zip,.rar" style="display:none">
                    <button id="image-button" class="media-btn" title="Enviar imagen">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><circle cx="8.5" cy="8.5" r="1.5"/><polyline points="21 15 16 10 5 21"/></svg>
                    </button>
                    <button id="video-button" class="media-btn" title="Enviar video">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="23 7 16 12 23 17 23 7"/><rect x="1" y="5" width="15" height="14" rx="2" ry="2"/></svg>
                    </button>
                    <button id="doc-button" class="media-btn" title="Enviar documento">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>
                    </button>
                    <button id="nudge-button" class="media-btn" title="Enviar zumbido">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round"><path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"/></svg>
                    </button>
                    <button id="mic-button" class="media-btn" title="Grabar audio">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg>
                    </button>
                    <button id="mic-cancel-button" class="audio-cancel-btn" title="Cancelar grabación">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
                    </button>
                </div>
                <div class="message-input-area">
                    <button id="emoji-button" class="input-icon-btn" title="Insertar Emoji">
                        <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M8 14s1.5 2 4 2 4-2 4-2"/><line x1="9" y1="9" x2="9.01" y2="9"/><line x1="15" y1="9" x2="15.01" y2="9"/></svg>
                    </button>
                    <textarea id="message-input" placeholder="Mensaje" autocomplete="off" autocorrect="off" rows="1"></textarea>
                    <button id="send-button" title="Enviar">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/></svg>
                    </button>
                </div>
            </div>
             </div>
    </div>

    <!-- Call Participant Selector -->
    <div id="call-selector-modal">
        <div class="call-selector-card">
            <h3 id="call-selector-title">Selecciona participantes</h3>
            <div class="call-selector-list" id="call-selector-list"></div>
            <div class="call-selector-actions">
                <button class="call-selector-cancel" id="call-selector-cancel">Cancelar</button>
                <button class="call-selector-start" id="call-selector-start">Llamar</button>
            </div>
        </div>
    </div>

    <!-- Call Overlay -->
    <div id="call-overlay">
        <button id="minimize-call-btn" title="Minimizar">⬇</button>
        <div class="mini-expand-hint">⬆</div>
        <div class="call-status" id="call-status">Llamando...</div>
        <div class="call-name" id="call-peer-name"></div>
        <div class="call-timer" id="call-timer" style="display:none">00:00</div>
        <div class="call-video-grid" id="call-video-grid"></div>
        <video id="local-video" class="local-video" autoplay playsinline muted></video>
        <div class="call-actions" id="call-actions-outgoing">
            <button class="toggle-btn" id="flip-camera-btn" style="display:none" title="Voltear cámara">🔄</button>
            <button class="toggle-btn speaker-off" id="speaker-btn" title="Altavoz">🔊</button>
            <button class="end-call" id="end-call-btn">📞</button>
        </div>
        <div class="call-actions" id="call-actions-incoming" style="display:none">
            <button class="end-call" id="reject-call-btn">❌</button>
            <button class="accept-call" id="accept-call-btn">📞</button>
        </div>
    </div>

    <!-- Image Lightbox -->
    <div id="image-lightbox">
        <button class="lightbox-close" id="lightbox-close">&times;</button>
        <img id="lightbox-img" src="" alt="Imagen">
        <button class="lightbox-download" id="lightbox-download">💾 Guardar imagen</button>
    </div>

    <!-- Lock Overlay -->
    <div id="lock-overlay">
        <div class="lock-content">
            <div class="lock-icon">🔒</div>
            <h2>No disponible</h2>
            <p>Esta página se encuentra bloqueada</p>
            <div class="lock-buttons">
                <button id="lock-help-btn" class="lock-btn primary">Ayuda</button>
                <button id="lock-more-btn" class="lock-btn secondary">Más opciones</button>
            </div>
        </div>
    </div>

    <!-- Password Modal -->
    <div id="password-modal">
        <div class="pw-modal-card">
            <h3 id="pw-modal-title">Ingresa la clave</h3>
            <input type="password" id="pw-modal-input" placeholder="Contraseña" autocomplete="off"/>
            <p id="pw-modal-error"></p>
            <div class="pw-modal-actions">
                <button id="pw-modal-cancel" class="lock-btn secondary">Cancelar</button>
                <button id="pw-modal-ok" class="lock-btn primary">Aceptar</button>
            </div>
        </div>
    </div>

    <!-- Prompt Modal (replaces browser prompt) -->
    <div id="prompt-modal">
        <div class="pw-modal-card">
            <h3 id="prompt-modal-title">Ingresa un valor</h3>
            <input type="text" id="prompt-modal-input" placeholder="" autocomplete="off"/>
            <div class="pw-modal-actions">
                <button id="prompt-modal-cancel" class="lock-btn secondary">Cancelar</button>
                <button id="prompt-modal-ok" class="lock-btn primary">Aceptar</button>
            </div>
        </div>
    </div>

    <!-- Confirm Modal -->
    <div id="confirm-modal">
        <div class="pw-modal-card">
            <h3 id="confirm-modal-title">Confirmar</h3>
            <p id="confirm-modal-message"></p>
            <div class="pw-modal-actions">
                <button id="confirm-modal-cancel" class="lock-btn secondary">Cancelar</button>
                <button id="confirm-modal-ok" class="lock-btn primary">Continuar</button>
            </div>
        </div>
    </div>

    <!-- Help Modal -->
    <div id="help-modal" style="display:none; position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.5); z-index:10000; align-items:center; justify-content:center;">
        <div class="pw-modal-card" style="max-width:440px; width:90%; max-height:85vh; overflow-y:auto;">
            <h3 style="text-align:center; margin-bottom:10px;">📖 Guía de iChat</h3>
            <div class="help-modal-body">
                <h3>🚀 ¿Qué es iChat?</h3>
                <p>iChat es una plataforma de mensajería instantánea inspirada en el clásico MSN Messenger. Funciona desde el navegador en <b>Android, iPhone, PC y Tablets</b> sin necesidad de instalar nada. No necesitas dar tu número de teléfono: solo elige un <b>nickname</b> y un <b>canal</b>.</p>

                <h3>📡 Canales</h3>
                <p>Los canales son salas de chat privadas. Cuando creas un canal nuevo, defines un <b>PIN</b> (para que otros puedan entrar) y una <b>Palabra Clave</b> secreta (solo para el dueño). La Palabra Clave te da el control total del canal: cambiar el PIN, expulsar miembros y activar/desactivar la aprobación de ingreso.</p>

                <h3>🔑 PIN vs Palabra Clave</h3>
                <p><b>PIN:</b> Se comparte con quienes quieres que entren al canal. Cualquiera con el PIN puede unirse.<br>
                <b>Palabra Clave:</b> Solo la conoce el dueño del canal. Sirve para administrar el canal: cambiar PIN, expulsar miembros, activar aprobación de ingreso y acceder a opciones avanzadas.</p>

                <h3>🛡️ Aprobación de Ingreso</h3>
                <p>Desde <b>⚙️ → Más opciones</b> (con la Palabra Clave), puedes activar la <b>aprobación de ingreso</b>. Si está activada, aunque alguien tenga el PIN, verá un mensaje de "Esperando aprobación..." hasta que alguien dentro del chat lo apruebe.</p>

                <h3>👢 Expulsar Miembros</h3>
                <p>Desde <b>⚙️ → Más opciones</b>, puedes ver la lista de usuarios conectados y expulsar a cualquiera. Solo necesitas la Palabra Clave del canal.</p>

                <h3>🔒 Bloqueo de Chat</h3>
                <p>Cualquier miembro puede bloquear la pantalla del chat. Para desbloquear se necesita el PIN del canal. Desde "Más opciones" en el bloqueo también puedes limpiar el chat.</p>

                <h3>📞 Llamadas y Videollamadas</h3>
                <p>Puedes hacer llamadas de voz y videollamadas directamente desde el chat usando los botones 📞 y 📹 en la barra superior. Incluye la opción de voltear cámara durante la videollamada.</p>

                <h3>📎 Multimedia</h3>
                <p>Envía <b>imágenes, videos, documentos y audios</b> directamente desde el chat. Los videos se comprimen automáticamente para una carga rápida. También puedes grabar notas de voz.</p>

                <h3>⚡ Zumbidos</h3>
                <p>Como en el clásico Messenger, puedes enviar <b>zumbidos</b> que harán vibrar la pantalla del receptor con el sonido icónico. Hay un cooldown de 5 segundos entre zumbidos.</p>

                <h3>📲 Instalar como App</h3>
                <p>En Android puedes instalar iChat como una app desde el navegador. En iPhone, usa Safari → Compartir → "Agregar a pantalla de inicio".</p>

                <h3>🔒 Privacidad</h3>
                <p>No se almacenan datos personales. No necesitas cuenta, email ni número de teléfono. Los mensajes se guardan en el canal y se pueden limpiar en cualquier momento.</p>
            </div>
            <div style="text-align:center; margin-top:14px;">
                <button class="lock-btn primary" id="help-modal-close">Entendido</button>
            </div>
        </div>
    </div>

    <!-- Owner Options Modal -->
    <div id="owner-modal" style="display:none; position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.5); z-index:10000; align-items:center; justify-content:center;">
        <div class="pw-modal-card" style="max-width:380px; width:90%;">
            <h3 style="text-align:center; margin-bottom:14px;">🛡️ Opciones de Administrador</h3>
            <div id="owner-modal-content" style="display:flex; flex-direction:column; gap:10px;">
                <div style="display:flex; align-items:center; justify-content:space-between; padding:10px; background:#f8f9fa; border-radius:8px;">
                    <span style="font-weight:600; font-size:0.92em;">Aprobación de ingreso</span>
                    <label style="position:relative; display:inline-block; width:44px; height:24px;">
                        <input type="checkbox" id="approval-toggle" style="opacity:0; width:0; height:0;">
                        <span style="position:absolute; cursor:pointer; top:0; left:0; right:0; bottom:0; background:#ccc; border-radius:24px; transition:0.3s;"></span>
                    </label>
                </div>
                <p style="font-size:0.78em; color:#888; margin:0; padding:0 4px;">Si está activado, los nuevos miembros necesitarán aprobación para entrar, aunque tengan el PIN.</p>
                <hr style="border:none; border-top:1px solid #e5e5ea; margin:4px 0;">
                <div id="owner-kick-section">
                    <p style="font-weight:600; font-size:0.92em; margin:0 0 8px 0;">Usuarios conectados:</p>
                    <div id="owner-users-list" style="max-height:200px; overflow-y:auto;"></div>
                </div>
            </div>
            <div style="text-align:center; margin-top:14px;">
                <button class="lock-btn secondary" id="owner-modal-close">Cerrar</button>
            </div>
        </div>
    </div>

    <!-- Approval Pending Overlay -->
    <div id="approval-pending-overlay" class="approval-pending-overlay" style="display:none;">
        <div class="spinner"></div>
        <h2>Esperando aprobación...</h2>
        <p>El administrador del canal debe aprobar tu ingreso</p>
        <button id="cancel-approval-btn">Cancelar</button>
    </div>

    <!-- Pending Requests Container (shown to channel members) -->
    <div id="pending-requests-container" style="display:none; position:fixed; bottom:80px; left:50%; transform:translateX(-50%); z-index:9998; max-width:400px; width:90%;"></div>

    <!-- iOS Install Banner -->
    <div class="ios-install-backdrop" id="ios-install-backdrop"></div>
    <div class="ios-install-banner" id="ios-install-banner">
        <div class="ios-banner-header">
            <h3>Instalar iChat</h3>
            <button class="ios-banner-close" id="ios-banner-close">✕</button>
        </div>
        <ul class="ios-banner-steps">
            <li>
                <div class="ios-step-icon">⬆️</div>
                <div><span class="ios-step-num">1.</span> Toca el botón <strong>Compartir</strong> (el cuadro con flecha hacia arriba) en la barra de Safari</div>
            </li>
            <li>
                <div class="ios-step-icon">➕</div>
                <div><span class="ios-step-num">2.</span> Desliza y selecciona <strong>"Agregar a pantalla de inicio"</strong></div>
            </li>
            <li>
                <div class="ios-step-icon">✅</div>
                <div><span class="ios-step-num">3.</span> Toca <strong>"Agregar"</strong> y listo, tendrás la app en tu iPhone</div>
            </li>
        </ul>
    </div>

    <audio id="notification-sound" src="sonido_mensaje.mp3" preload="auto"></audio>


    <script>
        // Detectar si estamos en APK (WebView) o PWA instalada
        (function() {
            const isStandalone = window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone;
            const ua = navigator.userAgent;
            const isWebView = /wv|WebView/.test(ua) || (ua.includes('Android') && !ua.includes('Chrome/'));
            if (isStandalone || isWebView) {
                document.documentElement.classList.add('app-mode');
            }
        })();

        // Configuración de tu aplicación web de Firebase
        const firebaseConfig = {
            apiKey: "AIzaSyCimRCv6S5u0FhsfWrW_3A0dQJy0uAKVro",
            authDomain: "facba-69d41.firebaseapp.com",
            databaseURL: "https://facba-69d41-default-rtdb.firebaseio.com",
            projectId: "facba-69d41",
            storageBucket: "facba-69d41.firebasestorage.app",
            messagingSenderId: "264089433073",
            appId: "1:264089433073:web:968551648758972eb74a50",
            measurementId: "G-NL7Y6NDH99"
        };

        // Inicializar Firebase
        const app = firebase.initializeApp(firebaseConfig);
        const database = firebase.database(); // Obtener la instancia de Realtime Database

        let userName = ''; // Variable para almacenar el nombre del usuario
        // Session ID único por dispositivo/navegador (persiste en localStorage)
        let sessionId = localStorage.getItem('ichat_session_id');
        if (!sessionId) {
            sessionId = 'sid_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            localStorage.setItem('ichat_session_id', sessionId);
        }
        // Verificar si un nombre ya fue usado por OTRA persona en un canal
        async function isNameTakenInChannel(name, channelId) {
            const msgRef = database.ref(`channels/${channelId}/messages`);
            const snap = await msgRef.orderByChild('name').equalTo(name).once('value');
            if (!snap.exists()) return false; // Nombre libre
            // Revisar si algún mensaje con ese nombre tiene un sid diferente al nuestro
            let takenByOther = false;
            snap.forEach(child => {
                const msg = child.val();
                if (msg.sid && msg.sid !== sessionId) {
                    takenByOther = true;
                }
                // Mensajes antiguos sin sid se consideran del mismo usuario si el nombre coincide con localStorage
                if (!msg.sid) {
                    // Si no tiene sid, verificar si el localStorage tiene ese nombre guardado para ese canal
                    const savedName = localStorage.getItem('chatName');
                    const savedChannel = localStorage.getItem('chatChannel');
                    if (!(savedName === name && savedChannel === channelId)) {
                        takenByOther = true;
                    }
                }
            });
            return takenByOther;
        }
        let typingTimeout; // Para manejar el indicador de escribiendo
        let initialLoadComplete = false; // Bandera para saber si la carga inicial de mensajes ha terminado
        let audioUnlocked = false; // Bandera para rastrear si el audio se ha desbloqueado


        // Variable para almacenar los datos del mensaje al que se está respondiendo
        let replyingToMessage = null;
        // Variable para almacenar el mensaje que se está editando
        let editingMessageId = null;
        let editingMessageText = null;

        // Intersection Observer para detectar cuando los mensajes son visibles
        let messageObserver;


        // Obtener elementos del DOM
        const namePrompt = document.getElementById('name-prompt');
        const nameInput = document.getElementById('name-input');
        const channelInput = document.getElementById('channel-input');
        const startChatButton = document.getElementById('start-chat-button');
        const chatInterface = document.getElementById('chat-interface');
        const chatBox = document.getElementById('chat-box');
        // Cambiado de input type="text" a textarea
        const messageInput = document.getElementById('message-input');
        const sendButton = document.getElementById('send-button');
        const typingIndicator = document.getElementById('typing-indicator'); // Elemento para el indicador
        const notificationSound = document.getElementById('notification-sound'); // Elemento de audio
        const emojiButton = document.getElementById('emoji-button'); // Botón de emoji
        const emojiPicker = document.getElementById('emoji-picker'); // Selector de emojis
        const replyPreview = document.getElementById('reply-preview'); // Vista previa de respuesta
        const replyNameSpan = replyPreview.querySelector('.reply-name');
        const replyTextSpan = replyPreview.querySelector('.reply-text');
        const cancelReplyButton = document.getElementById('cancel-reply-button');
        // Elementos para edición
        const editPreview = document.getElementById('edit-preview');
        const editTextSpan = editPreview.querySelector('.edit-text');
        const cancelEditButton = document.getElementById('cancel-edit-button');
        // Nuevos elementos para configuración
        const settingsButton = document.getElementById('settings-button'); // Ahora en chat-header
        const settingsDropdown = document.getElementById('settings-dropdown'); // Ahora en chat-header
        const clearChatButton = document.getElementById('clear-chat-button'); // Ahora dentro del dropdown
        const changeNameButton = document.getElementById('change-name-button'); // Nuevo botón para cambiar nombre
        const chatContainer = document.getElementById('chat-container'); // Referencia al contenedor principal
        const messageInputArea = document.querySelector('.message-input-area'); // Referencia al área de input
        const onlineUsersDiv = document.getElementById('online-users'); // Elemento para usuarios en línea
        const bottomFixedArea = document.getElementById('bottom-fixed-area'); // Nuevo contenedor fijo


        // --- Forzar mayúsculas en inputs ---
        nameInput.addEventListener('input', () => {
            const pos = nameInput.selectionStart;
            nameInput.value = nameInput.value.toUpperCase();
            nameInput.setSelectionRange(pos, pos);
        });
        channelInput.addEventListener('input', () => {
            const pos = channelInput.selectionStart;
            channelInput.value = channelInput.value.toUpperCase();
            channelInput.setSelectionRange(pos, pos);
        });

        // --- Lógica de Ingreso de Nombre ---
        startChatButton.addEventListener('click', async () => {
            const enteredName = nameInput.value.trim().toUpperCase();
            const enteredChannel = channelInput.value.trim().toUpperCase().replace(/[.$#\[\]\/]/g, '');

            if (!enteredName) { console.log('Por favor, ingresa un nombre.'); return; }
            if (!enteredChannel) { console.log('Por favor, ingresa un canal.'); return; }

            userName = enteredName;

            const success = await enterChannel(enteredChannel);
            if (!success) return;

            // Verificar si el nombre ya fue usado en este canal
            const nameTaken = await isNameTakenInChannel(enteredName, activeChannel);
            if (nameTaken) {
                alert(`El nombre "${enteredName}" ya fue usado en este canal. Usa otro nombre o pide que limpien el chat para liberarlo.`);
                userName = '';
                activeChannel = '';
                return;
            }

            namePrompt.style.display = 'none';
            chatInterface.style.display = 'flex';
            messageInput.focus();
            localStorage.setItem('chatName', userName);
            localStorage.setItem('chatChannel', activeChannel);
            document.getElementById('chat-title').textContent = activeChannel;
            initializeChat();
        });

        // Permitir presionar Enter en los campos de nombre y canal
        nameInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                channelInput.focus(); // Mover al campo de canal
            }
        });
        channelInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                startChatButton.click(); // Simular clic en el botón
            }
        });

        // --- Función para inicializar la carga y los listeners del chat ---
        function initializeChat() {
             console.log("initializeChat function called.");
             setupMessageObserver(); // Configurar el Intersection Observer
             loadInitialMessages(); // Cargar mensajes existentes una vez
             setupRealtimeListeners(); // Configurar listeners en tiempo real una vez
             setupTypingIndicator(); // Configurar el indicador de escribiendo
             setupPresence(); // Configurar la presencia del usuario
             setupChatLockListener(); // Escuchar estado de bloqueo global
             setupPendingRequestsListener(); // Escuchar solicitudes de ingreso pendientes
             setupKickedListener(); // Escuchar si el usuario fue expulsado
             requestNotificationPermission(); // Solicitar permiso de notificaciones
             setTimeout(cleanupExpiredMedia, 3000); // Limpiar media expirada al iniciar
        }


        // --- Lógica del Chat (Realtime Database) ---

        // Referencias dinámicas al canal activo (se asignan al entrar a un canal)
        let messagesRef, typingRef, presenceRef, chatLockRef;
        let activeChannel = '';

        function setupChannelRefs(channelId) {
            messagesRef = database.ref(`channels/${channelId}/messages`);
            typingRef = database.ref(`channels/${channelId}/typing`);
            presenceRef = database.ref(`channels/${channelId}/presence`);
            chatLockRef = database.ref(`channels/${channelId}/chat_lock`);
        }


        // Clave para limpiar el chat (¡Mantén esto seguro en una aplicación real!)
        const CLEAR_CHAT_PASSWORD = '9999';


        // --- Lógica de Canales ---
        async function enterChannel(channelId) {
            const channelConfigRef = database.ref(`channels/${channelId}/config`);
            const snapshot = await channelConfigRef.once('value');

            if (snapshot.exists()) {
                // Canal existe, pedir PIN
                const config = snapshot.val();
                const ok = await showPasswordModal('Ingresa el PIN del canal ' + channelId, config.pin);
                if (!ok) return false;

                // Verificar si requiere aprobación
                if (config.requireApproval) {
                    activeChannel = channelId;
                    setupChannelRefs(channelId);
                    const approved = await waitForApproval(channelId, userName);
                    if (!approved) {
                        activeChannel = '';
                        return false;
                    }
                    return true;
                }
            } else {
                // Canal nuevo, confirmar creación
                const okCreate = await showConfirmModal(
                    'Canal nuevo',
                    `El canal ${channelId} no existe. Estás a punto de crear un canal nuevo. ¿Deseas continuar?`
                );
                if (!okCreate) return false;
                // Pedir crear PIN
                const pin = await showPromptModal('Crea un PIN para el canal ' + channelId, 'PIN (ej: 1234)');
                if (!pin) return false;
                // Pedir palabra clave del dueño
                const keyword = await showPromptModal('Crea una Palabra Clave secreta (solo para el dueño del canal)', 'Palabra clave');
                if (!keyword) return false;
                await channelConfigRef.set({
                    pin: pin,
                    keyword: keyword,
                    createdBy: userName,
                    createdAt: firebase.database.ServerValue.TIMESTAMP,
                    requireApproval: false
                });
            }

            activeChannel = channelId;
            setupChannelRefs(channelId);
            return true;
        }

        // --- Sistema de Aprobación de Ingreso ---
        async function waitForApproval(channelId, requestingUser) {
            return new Promise((resolve) => {
                const pendingRef = database.ref(`channels/${channelId}/pending/${requestingUser}`);
                const overlay = document.getElementById('approval-pending-overlay');
                const cancelBtn = document.getElementById('cancel-approval-btn');
                let listener;

                // Mostrar overlay de espera
                overlay.style.display = 'flex';

                // Escribir solicitud pendiente
                pendingRef.set({
                    name: requestingUser,
                    timestamp: firebase.database.ServerValue.TIMESTAMP,
                    status: 'pending'
                });

                // Escuchar cambios en el status
                listener = pendingRef.on('value', (snap) => {
                    const data = snap.val();
                    if (!data) {
                        // Fue rechazado (eliminado)
                        overlay.style.display = 'none';
                        pendingRef.off('value', listener);
                        resolve(false);
                    } else if (data.status === 'approved') {
                        overlay.style.display = 'none';
                        pendingRef.remove();
                        pendingRef.off('value', listener);
                        resolve(true);
                    }
                });

                // Cancelar solicitud
                cancelBtn.addEventListener('click', () => {
                    overlay.style.display = 'none';
                    pendingRef.remove();
                    pendingRef.off('value', listener);
                    resolve(false);
                }, { once: true });

                // Limpiar al desconectar
                pendingRef.onDisconnect().remove();
            });
        }

        // --- Listener de solicitudes pendientes (para miembros del chat) ---
        function setupPendingRequestsListener() {
            if (!activeChannel) return;
            const pendingRef = database.ref(`channels/${activeChannel}/pending`);
            const container = document.getElementById('pending-requests-container');

            pendingRef.on('value', (snapshot) => {
                const pending = snapshot.val();
                container.innerHTML = '';

                if (!pending || Object.keys(pending).length === 0) {
                    container.style.display = 'none';
                    return;
                }

                container.style.display = 'block';
                Object.entries(pending).forEach(([key, req]) => {
                    if (req.status !== 'pending') return;
                    const div = document.createElement('div');
                    div.className = 'pending-request';
                    div.innerHTML = `
                        <span class="pr-name">👤 ${req.name} quiere unirse</span>
                        <div class="pr-actions">
                            <button class="pr-btn pr-approve" onclick="approveRequest('${key}')">✓</button>
                            <button class="pr-btn pr-reject" onclick="rejectRequest('${key}')">✕</button>
                        </div>
                    `;
                    container.appendChild(div);
                });
            });
        }

        function approveRequest(userName) {
            if (!activeChannel) return;
            database.ref(`channels/${activeChannel}/pending/${userName}`).update({ status: 'approved' });
        }

        function rejectRequest(userName) {
            if (!activeChannel) return;
            database.ref(`channels/${activeChannel}/pending/${userName}`).remove();
        }


        // Función para formatear el timestamp a 12h AM/PM
        function formatTimestamp(timestamp) {
            if (!timestamp) return '';
            const date = new Date(timestamp);
            let hours = date.getHours();
            const minutes = date.getMinutes().toString().padStart(2, '0');
            const ampm = hours >= 12 ? 'p.m.' : 'a.m.';
            hours = hours % 12 || 12;
            return `${hours}:${minutes} ${ampm}`;
        }

        // Función para enviar un mensaje (texto, respuesta o edición)
        function sendMessage() {
            console.log("sendMessage function called.");
            const messageText = messageInput.value.trim();
            console.log("Message text:", messageText);
            console.log("User name:", userName);

            if (!messageText || !userName) {
                console.log("Message not sent: text or user name missing.");
                return;
            }

            // Si estamos editando un mensaje existente
            if (editingMessageId) {
                if (messageText === editingMessageText) {
                    // No hay cambios, solo cancelar modo edición
                    cancelEdit();
                    return;
                }
                // Actualizar el mensaje existente
                messagesRef.child(editingMessageId).update({
                    text: messageText,
                    edited: true
                }).then(() => {
                    console.log("Mensaje editado exitosamente!");
                    messageInput.value = '';
                    setTypingStatus(false);
                    cancelEdit();
                    messageInput.style.height = 'auto';
                    messageInput.focus();
                }).catch((error) => {
                    console.error("Error al editar mensaje:", error);
                });
                return;
            }

            // Es un mensaje nuevo
            const newMessage = {
                name: userName,
                text: messageText,
                timestamp: firebase.database.ServerValue.TIMESTAMP,
                status: 'sent',
                sid: sessionId
            };

            // Si estamos respondiendo a un mensaje, añadir la referencia
            if (replyingToMessage) {
                newMessage.replyTo = {
                    id: replyingToMessage.id,
                    name: replyingToMessage.name,
                    content: replyingToMessage.text ? replyingToMessage.text.substring(0, 50) + (replyingToMessage.text.length > 50 ? '...' : '') : 'Archivo'
                };
                console.log("Sending as a reply to:", replyingToMessage.id);
            }

            console.log("Attempting to send message to Realtime Database:", newMessage);

            messagesRef.push(newMessage)
                .then(() => {
                    console.log("Mensaje enviado exitosamente a Realtime Database!");
                    messageInput.value = '';
                    setTypingStatus(false);
                    cancelReply();
                    messageInput.style.height = 'auto';
                    messageInput.focus();
                })
                .catch((error) => {
                    console.error("Error al enviar mensaje a Realtime Database:", error);
                });
        }

        // Listener para el botón de enviar texto
        sendButton.addEventListener('click', sendMessage);
        // Evitar que el botón de enviar robe el foco del textarea (mantener teclado abierto en móvil)
        sendButton.addEventListener('touchstart', (e) => { e.preventDefault(); sendMessage(); });

        // Permitir presionar Enter en el campo de mensaje de texto (solo si no hay Shift)
        messageInput.addEventListener('keypress', (event) => {
            // Si es Enter y no Shift+Enter
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault(); // Prevenir el salto de línea por defecto
                sendMessage(); // Enviar el mensaje
            }
            // Si es Shift+Enter, permitir el salto de línea
        });


         // --- Lógica de Ajuste de Altura del Textarea ---

        // Función para ajustar la altura del textarea automáticamente
        function adjustTextareaHeight() {
             // Restablecer la altura a 'auto' para que se recalcule correctamente
            messageInput.style.height = 'auto';
            // Establecer la altura al scrollHeight (altura necesaria para mostrar todo el contenido)
            // Limitar por max-height definido en CSS
            messageInput.style.height = messageInput.scrollHeight + 'px';
            // Después de ajustar la altura del textarea, ajustar el padding inferior del chatBox
            adjustChatBoxPadding();
        }

        // Listener para el evento 'input' en el textarea para ajustar la altura
        messageInput.addEventListener('input', adjustTextareaHeight);


         // --- Lógica del Indicador de Escribiendo (Realtime Database) ---

        // Función para establecer el estado de escritura en Realtime Database
        function setTypingStatus(isTyping) {
            if (!userName) return; // No hacer nada si el nombre del usuario no está establecido

            const userTypingRef = typingRef.child(userName); // Referencia al estado del usuario actual en RTDB

            if (isTyping) {
                userTypingRef.set(true); // Establecer el estado a true
                // Limpiar el estado después de un tiempo si el usuario deja de escribir
                if (typingTimeout) clearTimeout(typingTimeout);
                typingTimeout = setTimeout(() => {
                    userTypingRef.remove(); // Eliminar el estado después de 1.5 segundos
                }, 1500);
            } else {
                 // Limpiar el timeout si existe
                 if (typingTimeout) {
                     clearTimeout(typingTimeout);
                     typingTimeout = null;
                 }
                 userTypingRef.remove(); // Eliminar el estado si ya no está escribiendo
            }
        }

        // Listener para el campo de entrada de mensaje para detectar escritura
        messageInput.addEventListener('input', () => {
            if (messageInput.value.trim().length > 0) {
                setTypingStatus(true); // El usuario está escribiendo
            } else {
                setTypingStatus(false); // El usuario ha borrado el texto
            }
        });

        // Configurar el listener para el estado de escritura de otros usuarios
        function setupTypingIndicator() {
            typingRef.on('value', (snapshot) => { // Listener en RTDB
                const typingUsers = snapshot.val();
                const usersTyping = [];

                if (typingUsers) {
                    // Iterar sobre los usuarios que están escribiendo
                    for (const name in typingUsers) {
                        // Asegurarse de que no sea el usuario actual
                        if (name !== userName) {
                            usersTyping.push(name);
                        }
                    }
                }

                // Actualizar el texto del indicador
                if (usersTyping.length > 0) {
                    typingIndicator.textContent = `${usersTyping.join(', ')} está escribiendo...`;
                } else {
                    typingIndicator.textContent = ''; // Limpiar si nadie está escribiendo
                }
                // Después de actualizar el indicador, ajustar el padding del chatBox
                adjustChatBoxPadding();
            });
        }


        // --- Lógica para Cargar Mensajes Iniciales (Realtime Database) ---
        function loadInitialMessages() {
             console.log("loadInitialMessages function called."); // Debugging log

             // Cargar mensajes existentes una vez al inicio
             messagesRef.once('value', (snapshot) => {
                 console.log("Initial message load from Realtime Database complete.");
                 const messages = snapshot.val();
                 if (messages) {
                     // Convertir objeto de mensajes a array y ordenar por timestamp
                     const messageList = Object.keys(messages).map(key => ({ id: key, ...messages[key] }));
                     messageList.sort((a, b) => a.timestamp - b.timestamp);

                     // Limpiar el chatbox antes de cargar los mensajes existentes
                     chatBox.innerHTML = '';

                     messageList.forEach((msg) => {
                         displayMessage(msg, msg.id); // Pasar el ID a displayMessage
                     });
                 }
                 chatBox.scrollTop = chatBox.scrollHeight; // Scroll al final
                 initialLoadComplete = true; // Marcar la carga inicial como completa
             }, (error) => {
                 console.error("Error fetching initial messages from Realtime Database:", error);
             });
        }

        // --- Lógica para Configurar Listeners en Tiempo Real (Realtime Database) ---
        function setupRealtimeListeners() {
            console.log("setupRealtimeListeners function called.");

             // Escuchar en tiempo real los mensajes nuevos desde Realtime Database
             // Este listener solo se adjunta UNA VEZ
             messagesRef.on('child_added', (data) => {
                 const newMessage = data.val();
                 const messageId = data.key; // Obtener el ID único del mensaje
                 console.log(`[${userName}] child_added event:`, newMessage, "ID:", messageId); // Debugging log con nombre de usuario

                 // Solo mostrar el mensaje si no es parte de la carga inicial
                 // La bandera initialLoadComplete ayuda a diferenciar
                 if (initialLoadComplete) {
                    displayMessage(newMessage, messageId); // Mostrar el nuevo mensaje
                    // Reproducir sonido si el mensaje no es del usuario actual
                     if (newMessage.name !== userName) {
                         playNotificationSound();
                     }
                    chatBox.scrollTop = chatBox.scrollHeight; // Scroll al final
                 } else {
                     // Si aún no ha terminado la carga inicial, no hacemos nada con este evento
                     // porque ya se mostrará en loadInitialMessages
                     console.log(`[${userName}] Ignoring child_added event during initial load.`); // Debugging log con nombre de usuario
                 }

             }, (error) => {
                 console.error(`[${userName}] Error in realtime listener for messages (child_added):`, error); // Debugging log con nombre de usuario
             });

             // Listener para actualizar el estado de los mensajes (doble check + ediciones)
             messagesRef.on('child_changed', (data) => {
                 const changedMessage = data.val();
                 const messageId = data.key;
                 console.log(`[${userName}] child_changed event: Message ${messageId} changed to:`, changedMessage);

                 const messageElement = chatBox.querySelector(`[data-message-id="${messageId}"]`);
                 if (!messageElement) return;

                 const messageFooter = messageElement.querySelector('.message-footer');

                 // Actualizar doble check si el mensaje fue leído
                 if (changedMessage.name === userName && changedMessage.status === 'read' && messageFooter) {
                     const existingCheckmarks = messageFooter.querySelector('.checkmarks');
                     if (existingCheckmarks) existingCheckmarks.remove();
                     const checkmarksSpan = document.createElement('span');
                     checkmarksSpan.classList.add('checkmarks');
                     checkmarksSpan.textContent = '✓✓';
                     messageFooter.appendChild(checkmarksSpan);
                 }

                 // Actualizar texto si fue editado
                 if (changedMessage.edited) {
                     const textSpan = messageElement.querySelector('.text');
                     if (textSpan) {
                         const urlRegex = /(https?:\/\/[^\s]+)/g;
                         textSpan.innerHTML = changedMessage.text.replace(urlRegex, '<a href="$1" target="_blank">$1</a>');
                     }
                     // Agregar etiqueta "editado" si no existe
                     if (messageFooter && !messageFooter.querySelector('.edited-label')) {
                         const editedSpan = document.createElement('span');
                         editedSpan.classList.add('edited-label');
                         editedSpan.textContent = 'editado';
                         messageFooter.insertBefore(editedSpan, messageFooter.firstChild);
                     }
                 }
             }, (error) => {
                 console.error(`[${userName}] Error in realtime listener for message changes (child_changed):`, error);
             });

             // Listener para eliminar mensajes individuales del DOM en tiempo real
             messagesRef.on('child_removed', (data) => {
                 const messageId = data.key;
                 const messageElement = chatBox.querySelector(`[data-message-id="${messageId}"]`);
                 if (messageElement) {
                     messageElement.remove();
                     console.log(`[${userName}] Message ${messageId} removed from DOM.`);
                 }
             });

             // Listener para reflejar borrados masivos del nodo 'messages' (por ejemplo, al limpiar el chat)
             messagesRef.on('value', (snapshot) => {
                 // Si el nodo no existe o queda vacío, limpiar el DOM del chat
                 if (!snapshot.exists()) {
                     clearChatUI();
                 }
             }, (error) => {
                 console.error(`[${userName}] Error in realtime listener for messages (value):`, error);
             });
        }

        function clearChatUI(){
            chatBox.innerHTML = '';
            typingIndicator.textContent = '';
            // Reset del estado de respuesta si estaba activo
            replyingToMessage = null;
            replyPreview.style.display = 'none';
            replyNameSpan.textContent = '';
            replyTextSpan.textContent = '';
            // Reset del estado de edición si estaba activo
            editingMessageId = null;
            editingMessageText = null;
            editPreview.style.display = 'none';
            editTextSpan.textContent = '';
            // Ocultar selector/menús abiertos
            emojiPicker.style.display = 'none';
            settingsDropdown.style.display = 'none';
            // Ajustar padding por si cambia la altura del área fija
            adjustChatBoxPadding();
        }


        // --- Configurar Intersection Observer ---
        function setupMessageObserver() {
            const options = {
                root: chatBox, // Observar dentro del chatBox
                rootMargin: '0px',
                threshold: 0.5 // El mensaje se considera visible si al menos el 50% está en el viewport
            };

            messageObserver = new IntersectionObserver((entries, observer) => {
                entries.forEach(entry => {
                    // Si el mensaje es visible (intersecting) y es un mensaje recibido por este usuario
                    if (entry.isIntersecting && entry.target.classList.contains('received')) {
                        const messageElement = entry.target;
                        const messageId = messageElement.dataset.messageId;
                        // Obtener el estado actual del mensaje de la base de datos para evitar escrituras innecesarias
                        messagesRef.child(messageId).once('value', (snapshot) => {
                            const messageData = snapshot.val();
                            // Mark as read only if the status is not already 'read'
                            if (messageData && messageData.status !== 'read') {
                                console.log(`[${userName}] Message ${messageId} is now visible. Marking as read.`);
                                messagesRef.child(messageId).update({ status: 'read' })
                                    .then(() => console.log(`[${userName}] Message ${messageId} marked as read successfully via Observer.`))
                                    .catch(error => console.error(`[${userName}] Error marking message ${messageId} as read via Observer:`, error));
                            } else {
                                console.log(`[${userName}] Message ${messageId} is visible but already read or not found.`);
                            }
                        });
                        // Dejar de observar este mensaje una vez que se marca como leído
                        observer.unobserve(messageElement);
                    }
                });
            }, options);
             console.log(`[${userName}] Intersection Observer configured.`);
        }


        // Función para mostrar un mensaje en el DOM
        function displayMessage(msg, messageId) {
            console.log(`[${userName}] Displaying message:`, msg, "ID:", messageId); // Debugging log con nombre de usuario

            // --- Zumbido / Nudge ---
            if (msg.type === 'nudge') {
                const wrapper = document.createElement('div');
                wrapper.classList.add('nudge-message-wrapper');
                wrapper.dataset.messageId = messageId;
                const nudgeDiv = document.createElement('div');
                nudgeDiv.classList.add('nudge-message');
                nudgeDiv.textContent = `⚡ ${msg.name} te ha enviado un zumbido`;
                wrapper.appendChild(nudgeDiv);
                chatBox.appendChild(wrapper);
                // Activar shake si es mensaje nuevo (no carga inicial) y no es del usuario actual
                if (initialLoadComplete && msg.name !== userName) {
                    triggerNudgeEffect();
                }
                return;
            }

            const messageElement = document.createElement('div');
            messageElement.classList.add('message');
            messageElement.dataset.messageId = messageId; // Almacenar el ID del mensaje en el elemento DOM

            // Añadir clase 'sent' o 'received'
            if (msg.name === userName) {
                messageElement.classList.add('sent');
                 console.log(`[${userName}] Message ${messageId} is SENT. Initial status: ${msg.status}`); // Log initial status for sent message
            } else {
                messageElement.classList.add('received');
                 console.log(`[${userName}] Message ${messageId} is RECEIVED from ${msg.name}.`); // Debugging log con nombre de usuario
                // La lógica para marcar como leído ahora está en el Intersection Observer
            }

            // Crear elementos para el nombre y contenido
            const nameSpan = document.createElement('span');
            nameSpan.classList.add('name');
            /* Solo mostrar el nombre si no es el mensaje del usuario actual (opcional, estilo WhatsApp) */
            if (msg.name !== userName) {
               nameSpan.textContent = msg.name + ': ';
            } else {
               nameSpan.textContent = ''; // No mostrar el nombre en mensajes propios
            }

            // Crear el contenedor para el texto, hora y checkmarks
            const messageFooter = document.createElement('div');
            messageFooter.classList.add('message-footer');

            // Crear elementos para el texto y timestamp
            const textSpan = document.createElement('span');
            textSpan.classList.add('text');
            textSpan.textContent = msg.text || '';
            console.log(`[${userName}] textSpan created for message ${messageId}. Content: "${textSpan.textContent}"`); // Debugging log: contenido del texto

            // --- Aplicar estilos inline para asegurar visibilidad y color ---
            // Estos estilos inline tienen alta prioridad y deberían forzar la visibilidad y color.
            textSpan.style.visibility = 'visible';
            textSpan.style.display = 'block'; // O 'inline-block' si prefieres
            if (msg.name === userName) {
                textSpan.style.color = 'white'; // Color blanco para mensajes enviados
            } else {
                textSpan.style.color = '#1c1c1e'; // Color oscuro para mensajes recibidos
            }
            console.log(`[${userName}] textSpan for message ${messageId} inline styles applied -> Color: ${textSpan.style.color}, Visibility: ${textSpan.style.visibility}, Display: ${textSpan.style.display}`); // Log inline styles


            const timestampSpan = document.createElement('span');
            timestampSpan.classList.add('timestamp');
            timestampSpan.textContent = formatTimestamp(msg.timestamp); // Formatear y mostrar hora


            // Añadir nombre al elemento del mensaje si no es el usuario actual
            if (msg.name !== userName) {
                 messageElement.appendChild(nameSpan);
            }

            // --- Mostrar contenido de la respuesta si existe ---
            if (msg.replyTo) {
                const replyContentDiv = document.createElement('div');
                replyContentDiv.classList.add('reply-content');

                const replyName = document.createElement('span');
                replyName.classList.add('reply-name');
                replyName.textContent = msg.replyTo.name + ':';

                const replyText = document.createElement('span');
                replyText.classList.add('reply-text');
                replyText.textContent = msg.replyTo.content;

                replyContentDiv.appendChild(replyName);
                replyContentDiv.appendChild(replyText);
                messageElement.appendChild(replyContentDiv);
            }
            /* --- Fin de mostrar contenido de respuesta --- */

            // --- Renderizar según tipo de mensaje ---
            if (msg.type === 'image') {
                const age = Date.now() - (msg.timestamp || 0);
                const TWENTY_FOUR_H = 24 * 60 * 60 * 1000;
                if (!msg.imageData || age >= TWENTY_FOUR_H) {
                    // Imagen expirada
                    const placeholder = document.createElement('div');
                    placeholder.classList.add('image-expired-placeholder');
                    placeholder.textContent = '📷 Imagen expirada (24h)';
                    messageElement.appendChild(placeholder);
                } else {
                    const wrapper = document.createElement('div');
                    wrapper.classList.add('image-wrapper');

                    const img = document.createElement('img');
                    img.classList.add('message-image');
                    img.src = msg.imageData;
                    img.alt = 'Imagen';
                    img.onload = () => { chatBox.scrollTop = chatBox.scrollHeight; };
                    img.onclick = () => {
                        const lb = document.getElementById('image-lightbox');
                        document.getElementById('lightbox-img').src = msg.imageData;
                        lb.classList.add('active');
                    };
                    wrapper.appendChild(img);

                    // Badge con tiempo restante
                    const badge = document.createElement('div');
                    badge.classList.add('image-expiry-badge');
                    const hoursLeft = Math.max(0, Math.ceil((TWENTY_FOUR_H - age) / (60 * 60 * 1000)));
                    badge.textContent = `⏳ ${hoursLeft}h restantes`;
                    wrapper.appendChild(badge);

                    // Botón descargar
                    const dlBtn = document.createElement('button');
                    dlBtn.classList.add('image-download-btn');
                    dlBtn.textContent = '💾';
                    dlBtn.title = 'Guardar imagen';
                    dlBtn.onclick = (e) => {
                        e.stopPropagation();
                        const a = document.createElement('a');
                        a.href = msg.imageData;
                        a.download = `chat_img_${messageId}.jpg`;
                        a.click();
                    };
                    wrapper.appendChild(dlBtn);

                    messageElement.appendChild(wrapper);
                }
            } else if (msg.type === 'audio' && msg.audioData) {
                // Custom audio player
                const playerDiv = document.createElement('div');
                playerDiv.classList.add('audio-player-custom');

                const audioEl = document.createElement('audio');
                audioEl.preload = 'metadata';
                audioEl.src = msg.audioData;

                const playBtn = document.createElement('button');
                playBtn.classList.add('audio-play-btn');
                playBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="currentColor"><polygon points="6,3 20,12 6,21"/></svg>';

                const trackDiv = document.createElement('div');
                trackDiv.classList.add('audio-track');

                const progressBar = document.createElement('input');
                progressBar.type = 'range';
                progressBar.classList.add('audio-progress-bar');
                progressBar.min = '0';
                progressBar.max = '100';
                progressBar.value = '0';
                progressBar.step = '0.1';

                const timeSpanRow = document.createElement('div');
                timeSpanRow.style.display = 'flex';
                timeSpanRow.style.justifyContent = 'space-between';
                const currentTime = document.createElement('span');
                currentTime.classList.add('audio-time');
                currentTime.textContent = '0:00';
                const durationSpan = document.createElement('span');
                durationSpan.classList.add('audio-time');
                durationSpan.textContent = '0:00';
                timeSpanRow.appendChild(currentTime);
                timeSpanRow.appendChild(durationSpan);

                const speedBtn = document.createElement('button');
                speedBtn.classList.add('audio-speed-btn');
                speedBtn.textContent = '1x';
                speedBtn.title = 'Velocidad de reproducción';
                const speeds = [1, 1.5, 2];
                let speedIdx = 0;
                speedBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    speedIdx = (speedIdx + 1) % speeds.length;
                    audioEl.playbackRate = speeds[speedIdx];
                    speedBtn.textContent = speeds[speedIdx] + 'x';
                });

                trackDiv.appendChild(progressBar);
                trackDiv.appendChild(timeSpanRow);

                playerDiv.appendChild(playBtn);
                playerDiv.appendChild(trackDiv);
                playerDiv.appendChild(speedBtn);
                messageElement.appendChild(playerDiv);

                const fmtTime = (s) => {
                    if (isNaN(s)) return '0:00';
                    const m = Math.floor(s / 60);
                    const sec = Math.floor(s % 60);
                    return m + ':' + (sec < 10 ? '0' : '') + sec;
                };

                audioEl.addEventListener('loadedmetadata', () => {
                    durationSpan.textContent = fmtTime(audioEl.duration);
                });
                audioEl.addEventListener('timeupdate', () => {
                    if (audioEl.duration) {
                        progressBar.value = (audioEl.currentTime / audioEl.duration) * 100;
                        currentTime.textContent = fmtTime(audioEl.currentTime);
                    }
                });
                audioEl.addEventListener('ended', () => {
                    playBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="currentColor"><polygon points="6,3 20,12 6,21"/></svg>';
                    progressBar.value = '0';
                    currentTime.textContent = '0:00';
                });
                playBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (audioEl.paused) {
                        audioEl.play();
                        playBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="currentColor"><rect x="5" y="3" width="4" height="18" rx="1"/><rect x="15" y="3" width="4" height="18" rx="1"/></svg>';
                    } else {
                        audioEl.pause();
                        playBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="currentColor"><polygon points="6,3 20,12 6,21"/></svg>';
                    }
                });
                progressBar.addEventListener('input', (e) => {
                    e.stopPropagation();
                    if (audioEl.duration) {
                        audioEl.currentTime = (progressBar.value / 100) * audioEl.duration;
                    }
                });
                progressBar.addEventListener('click', (e) => e.stopPropagation());
            } else if (msg.type === 'video') {
                const age = Date.now() - (msg.timestamp || 0);
                const TWENTY_FOUR_H = 24 * 60 * 60 * 1000;
                if (!msg.videoData || age >= TWENTY_FOUR_H) {
                    const placeholder = document.createElement('div');
                    placeholder.classList.add('doc-expired-placeholder');
                    placeholder.textContent = '🎬 Video expirado (24h)';
                    messageElement.appendChild(placeholder);
                } else {
                    const wrapper = document.createElement('div');
                    wrapper.classList.add('video-wrapper');

                    const vid = document.createElement('video');
                    vid.classList.add('message-video');
                    vid.src = msg.videoData;
                    vid.controls = true;
                    vid.preload = 'metadata';
                    vid.setAttribute('playsinline', '');
                    vid.onloadeddata = () => { chatBox.scrollTop = chatBox.scrollHeight; };
                    vid.onclick = (e) => e.stopPropagation();
                    wrapper.appendChild(vid);

                    const hoursLeft = Math.max(0, Math.ceil((TWENTY_FOUR_H - age) / (60 * 60 * 1000)));
                    const badge = document.createElement('div');
                    badge.classList.add('image-expiry-badge');
                    badge.textContent = `⏳ ${hoursLeft}h`;
                    wrapper.appendChild(badge);

                    const dlBtn = document.createElement('button');
                    dlBtn.classList.add('image-download-btn');
                    dlBtn.textContent = '💾';
                    dlBtn.title = 'Guardar video';
                    dlBtn.onclick = (e) => {
                        e.stopPropagation();
                        const a = document.createElement('a');
                        a.href = msg.videoData;
                        a.download = `chat_vid_${messageId}.mp4`;
                        a.click();
                    };
                    wrapper.appendChild(dlBtn);
                    messageElement.appendChild(wrapper);
                }
            } else if (msg.type === 'document') {
                const age = Date.now() - (msg.timestamp || 0);
                const TWENTY_FOUR_H = 24 * 60 * 60 * 1000;
                if (!msg.docData || age >= TWENTY_FOUR_H) {
                    const placeholder = document.createElement('div');
                    placeholder.classList.add('doc-expired-placeholder');
                    placeholder.textContent = '📄 Documento expirado (24h)';
                    messageElement.appendChild(placeholder);
                } else {
                    const extMap = { pdf: '📕', doc: '📘', docx: '📘', xls: '📗', xlsx: '📗', ppt: '📙', pptx: '📙', txt: '📝', zip: '📦', rar: '📦' };
                    const fileName = msg.docName || 'documento';
                    const ext = fileName.split('.').pop().toLowerCase();
                    const icon = extMap[ext] || '📄';
                    const sizeText = msg.docSize ? (msg.docSize > 1024 * 1024 ? (msg.docSize / (1024 * 1024)).toFixed(1) + ' MB' : (msg.docSize / 1024).toFixed(0) + ' KB') : '';

                    const docDiv = document.createElement('div');
                    docDiv.classList.add('doc-attachment');

                    const iconDiv = document.createElement('div');
                    iconDiv.classList.add('doc-icon');
                    iconDiv.textContent = icon;

                    const infoDiv = document.createElement('div');
                    infoDiv.classList.add('doc-info');
                    const nameSpan = document.createElement('span');
                    nameSpan.classList.add('doc-name');
                    nameSpan.textContent = fileName;
                    infoDiv.appendChild(nameSpan);

                    if (sizeText) {
                        const hoursLeft = Math.max(0, Math.ceil((TWENTY_FOUR_H - age) / (60 * 60 * 1000)));
                        const sizeSpan = document.createElement('span');
                        sizeSpan.classList.add('doc-size');
                        sizeSpan.textContent = `${sizeText} · ⏳ ${hoursLeft}h`;
                        infoDiv.appendChild(sizeSpan);
                    }

                    docDiv.appendChild(iconDiv);
                    docDiv.appendChild(infoDiv);

                    docDiv.onclick = (e) => {
                        e.stopPropagation();
                        const a = document.createElement('a');
                        a.href = msg.docData;
                        a.download = fileName;
                        a.click();
                    };
                    messageElement.appendChild(docDiv);
                }
            } else {

            // --- Lógica para detectar y mostrar previsualización de videos o enlaces ---
            let contentElement = null; // Elemento que contendrá la previsualización o el texto del enlace

            // 1. Intentar detectar YouTube
            const youtubeUrlMatch = msg.text ? msg.text.match(/(?:https?:\/\/)?(?:www\.)?(?:youtube\.com|youtu\.be)\/(?:watch\?v=)?([a-zA-Z0-9_-]+)/) : null;
            if (youtubeUrlMatch && youtubeUrlMatch[1]) {
                const videoId = youtubeUrlMatch[1];
                const iframe = document.createElement('iframe');
                iframe.src = `https://www.youtube.com/embed/${videoId}`; // URL de incrustación estándar de YouTube
                iframe.setAttribute('allowfullscreen', ''); // Permitir pantalla completa
                iframe.setAttribute('loading', 'lazy'); // Carga diferida
                contentElement = iframe;
                console.log(`[${userName}] YouTube video detected for message ${messageId}. Video ID: ${videoId}`);
            } else {
                // 2. Intentar detectar Facebook Video (regex mejorada, pero puede no ser exhaustiva)
                const facebookUrlMatch = msg.text ? msg.text.match(/(?:https?:\/\/)?(?:www\.)?(?:facebook\.com)\/(?:watch\/)?(?:v=)?(?:videos\/)?([0-9]+)(?:\/)?/) : null;
                 if (facebookUrlMatch && facebookUrlMatch[1]) {
                     const videoId = facebookUrlMatch[1];
                     const iframe = document.createElement('iframe');
                     // URL de incrustación básica de Facebook (puede requerir ajustes dependiendo de la configuración)
                     iframe.src = `https://www.facebook.com/plugins/video.php?href=https%3A%2F%2Fwww.facebook.com%2Fwatch%2F%3Fv%3D${videoId}&show_text=0&width=560`;
                     iframe.setAttribute('allowfullscreen', '');
                     iframe.setAttribute('loading', 'lazy');
                     iframe.setAttribute('scrolling', 'no');
                     iframe.setAttribute('frameborder', '0');
                     iframe.setAttribute('allow', 'autoplay; clipboard-write; encrypted-media; picture-in-picture; web-share');
                     contentElement = iframe;
                     console.log(`[${userName}] Facebook video detected for message ${messageId}. Video ID: ${videoId}`);
                 } else {
                     // 3. Intentar detectar enlaces directos a archivos de video
                     const videoFileMatch = msg.text ? msg.text.match(/(https?:\/\/[^\s]+\.(mp4|webm|ogg))/) : null;
                     if (videoFileMatch && videoFileMatch[1]) {
                         const videoUrl = videoFileMatch[1];
                         const videoElement = document.createElement('video');
                         videoElement.src = videoUrl;
                         videoElement.setAttribute('controls', ''); // Mostrar controles de video
                         videoElement.setAttribute('preload', 'metadata'); // Cargar metadatos primero
                         contentElement = videoElement;
                         console.log(`[${userName}] Direct video file detected for message ${messageId}. URL: ${videoUrl}`);
                     } else {
                         // 4. Si no es un video soportado, mostrar el texto del mensaje con enlaces clicables
                         // Detectar URLs generales en el texto y convertirlas en enlaces clicables
                         const urlRegex = /(https?:\/\/[^\s]+)/g;
                         const textWithLinks = (msg.text || '').replace(urlRegex, '<a href="$1" target="_blank">$1</a>');
                         textSpan.innerHTML = textWithLinks; // Usar innerHTML para renderizar el enlace
                         contentElement = textSpan; // El texto con enlaces es el contenido principal
                         console.log(`[${userName}] No supported video detected for message ${messageId}. Displaying text with links.`);
                     }
                 }
            }

            // Si se encontró una previsualización de video, crear un contenedor y añadirla
            if (contentElement && (contentElement.tagName === 'IFRAME' || contentElement.tagName === 'VIDEO')) {
                const videoPreviewContainer = document.createElement('div');
                videoPreviewContainer.classList.add('video-preview-container');
                videoPreviewContainer.appendChild(contentElement);
                messageElement.appendChild(videoPreviewContainer); // Añadir el contenedor de previsualización al messageElement

                // Después de añadir la previsualización, añadir el texto original si no es solo la URL
                 if (msg.text && !youtubeUrlMatch && !facebookUrlMatch && !videoFileMatch) {
                     // Si el mensaje contenía texto además de la URL, añadir el textSpan original (ahora con enlaces clicables)
                     messageElement.appendChild(textSpan);
                     console.log(`[${userName}] Adding original textSpan after video preview for message ${messageId}.`);
                 } else if (msg.text && (youtubeUrlMatch || facebookUrlMatch || videoFileMatch)) {
                     // Si el mensaje es solo la URL del video, no es necesario añadir el textSpan de nuevo
                     console.log(`[${userName}] Message is only a video URL, not adding textSpan again for message ${messageId}.`);
                 }


            } else if (contentElement && contentElement.classList.contains('text')) {
                 // Si el contenido principal es el textSpan (con enlaces clicables)
                 messageElement.appendChild(contentElement); // Añadir el textSpan (que ya tiene el contenido)
                 console.log(`[${userName}] Adding textSpan as main content for message ${messageId}.`);
            }

            } // Cierre del else (tipo texto) del if image/audio


            // --- Añadir hora y checkmarks al footer ---
            // Mostrar etiqueta (editado) si aplica
            if (msg.edited) {
                const editedSpan = document.createElement('span');
                editedSpan.classList.add('edited-label');
                editedSpan.textContent = 'editado';
                messageFooter.appendChild(editedSpan);
            }

            messageFooter.appendChild(timestampSpan); // Añadir la hora

            // Añadir checkmarks si es un mensaje enviado por el usuario actual
            if (msg.name === userName) {
                 const checkmarksSpan = document.createElement('span');
                 checkmarksSpan.classList.add('checkmarks');
                 // Mostrar un check simple si el estado es 'sent', doble si es 'read'
                 checkmarksSpan.textContent = msg.status === 'read' ? '✓✓' : '✓'; // Unicode checkmarks
                 messageFooter.appendChild(checkmarksSpan); // Añadir los checkmarks al footer
                 console.log(`[${userName}] Displaying checkmarks for SENT message ${messageId}: ${checkmarksSpan.textContent}, based on status "${msg.status}"`); // Debugging log con nombre de usuario
            } else {
                 console.log(`[${userName}] Not displaying checkmarks for RECEIVED message ${messageId}.`); // Debugging log con nombre de usuario
            }

            messageElement.appendChild(messageFooter); // Asegurarse de que el footer se añade al messageElement
            console.log(`[${userName}] messageFooter appended to messageElement for message ${messageId}.`); // Log after appending messageFooter

            chatBox.appendChild(messageElement);
            console.log(`[${userName}] messageElement appended to chatBox for message ${messageId}.`); // Log after appending messageElement
            console.log(`[${userName}] chatBox after appending message ${messageId}:`, chatBox.innerHTML); // Log chatBox content


            // Después de añadir el messageElement al DOM, podemos obtener los estilos computados del textSpan
            // Aumentar el retraso para dar más tiempo a la renderización
            setTimeout(() => {
                 // Verificar si textSpan existe antes de intentar obtener estilos computados
                 if (textSpan && textSpan.parentElement) { // Asegurarse de que textSpan está en el DOM
                     const computedStyle = window.getComputedStyle(textSpan);
                     console.log(`[${userName}] textSpan for message ${messageId} computed style -> Color: ${computedStyle.color}, Visibility: ${computedStyle.visibility}, Display: ${computedStyle.display}`);
                 } else {
                     console.log(`[${userName}] textSpan not found in DOM for message ${messageId}. Skipping computed style log.`);
                 }


                 // Verificar también el estilo computado del messageFooter
                 const computedFooterStyle = window.getComputedStyle(messageFooter);
                 console.log(`[${userName}] messageFooter for message ${messageId} computed style -> Display: ${computedFooterStyle.display}, Visibility: ${computedFooterStyle.visibility}, Opacity: ${computedFooterStyle.opacity}`);

                 // Observar el mensaje si es un mensaje recibido
                 if (messageElement.classList.contains('received')) {
                     messageObserver.observe(messageElement);
                     console.log(`[${userName}] Observing received message ${messageId} with Intersection Observer.`);
                 }


            }, 500); // Retraso aumentado a 500ms


             // Sonido, vibración y notificación para mensajes entrantes
             if (initialLoadComplete && msg.name !== userName) {
                 playNotificationSound();
                 // Vibrar el dispositivo (200ms)
                 if (navigator.vibrate) {
                     navigator.vibrate(200);
                 }
                 // Notificación del sistema (siempre intentar)
                 showBrowserNotification(msg.name, msg.text || '📎 Archivo');
             }

             // Añadir listener de clic: menú de acciones para todos los mensajes
             messageElement.addEventListener('click', (e) => {
                 e.stopPropagation();
                 showMessageActions(messageId, msg, messageElement);
             });
        }

        // --- Menú de acciones para mensajes ---
        function showMessageActions(messageId, msg, element) {
            // Cerrar menú previo
            const existing = document.querySelector('.msg-actions-menu');
            if (existing) { existing.remove(); return; }

            const menu = document.createElement('div');
            menu.classList.add('msg-actions-menu');

            // Responder (para todos)
            const replyBtn = document.createElement('button');
            replyBtn.textContent = '↩️ Responder';
            replyBtn.onclick = (e) => { e.stopPropagation(); menu.remove(); startReply({ id: messageId, name: msg.name, text: msg.text || '' }); };
            menu.appendChild(replyBtn);

            // Editar y Eliminar solo para mensajes propios
            if (msg.name === userName) {
                const editBtn = document.createElement('button');
                editBtn.textContent = '✏️ Editar';
                editBtn.onclick = (e) => {
                    e.stopPropagation(); menu.remove();
                    const currentText = element.querySelector('.text') ? element.querySelector('.text').textContent : msg.text;
                    startEdit(messageId, currentText);
                };
                menu.appendChild(editBtn);

                const deleteBtn = document.createElement('button');
                deleteBtn.classList.add('delete-action');
                deleteBtn.textContent = '🗑️ Eliminar';
                deleteBtn.onclick = (e) => { e.stopPropagation(); menu.remove(); messagesRef.child(messageId).remove(); };
                menu.appendChild(deleteBtn);
            }

            // Posicionar con fixed en base a la posición del mensaje en pantalla
            document.body.appendChild(menu);
            const rect = element.getBoundingClientRect();
            const menuH = menu.offsetHeight;
            const isSent = msg.name === userName;

            // Vertical: si hay espacio arriba, mostrar arriba; si no, abajo
            if (rect.top - menuH - 4 > 0) {
                menu.style.top = (rect.top - menuH - 4) + 'px';
            } else {
                menu.style.top = (rect.bottom + 4) + 'px';
            }

            // Horizontal: alinear al lado del mensaje
            if (isSent) {
                menu.style.right = (window.innerWidth - rect.right) + 'px';
            } else {
                menu.style.left = rect.left + 'px';
            }

            // Cerrar al tocar fuera
            const closeMenu = (ev) => {
                if (!menu.contains(ev.target)) {
                    menu.remove();
                    document.removeEventListener('click', closeMenu, true);
                    document.removeEventListener('touchstart', closeMenu, true);
                }
            };
            setTimeout(() => {
                document.addEventListener('click', closeMenu, true);
                document.addEventListener('touchstart', closeMenu, true);
            }, 10);
        }

        // Función para reproducir el sonido de notificación
        function playNotificationSound() {
             if (notificationSound && audioUnlocked) { // Solo reproducir si el audio está desbloqueado
                 notificationSound.currentTime = 0; // Reiniciar el sonido si ya se está reproduciendo
                 notificationSound.play().catch(error => {
                     console.error("Error al reproducir el sonido:", error);
                     // Esto a menudo ocurre si el navegador bloquea el autoplay
                 });
             } else if (!audioUnlocked) {
                 console.log("Audio not unlocked yet. Cannot play sound.");
             }
        }

        // Solicitar permiso de notificaciones al entrar al chat
        function requestNotificationPermission() {
            if ('Notification' in window && Notification.permission === 'default') {
                Notification.requestPermission().then(perm => {
                    console.log('Notification permission:', perm);
                });
            }
        }

        // Mostrar notificación del sistema (usa Service Worker para compatibilidad con WebView)
        function showBrowserNotification(senderName, messageText) {
            if (!('Notification' in window) || Notification.permission !== 'granted') return;
            // Intentar vía Service Worker (funciona en WebView/APK)
            if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
                navigator.serviceWorker.ready.then(reg => {
                    reg.showNotification('iChat', {
                        body: `${senderName}: ${messageText}`,
                        icon: './icon-192.png',
                        tag: 'ichat-msg',
                        renotify: true,
                        vibrate: [200, 100, 200]
                    });
                }).catch(e => console.log('SW notification error:', e));
            } else {
                // Fallback: Notification API directa
                try {
                    const notif = new Notification('iChat', {
                        body: `${senderName}: ${messageText}`,
                        icon: './icon-192.png',
                        tag: 'ichat-msg',
                        renotify: true
                    });
                    notif.onclick = () => { window.focus(); notif.close(); };
                    setTimeout(() => notif.close(), 5000);
                } catch (e) {
                    console.log('Notification fallback error:', e);
                }
            }
        }

        // Función para intentar desbloquear el audio con una interacción del usuario
        function unlockAudio() {
            if (notificationSound && notificationSound.readyState >= 2 && !audioUnlocked) { // readyState 2 means enough data is available
                notificationSound.volume = 0; // Set volume to 0
                const playPromise = notificationSound.play();

                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        // Playback started successfully
                        notificationSound.pause(); // Pause immediately
                        notificationSound.volume = 1; // Restore volume
                        audioUnlocked = true; // Mark audio as unlocked
                        console.log("Audio unlocked successfully.");
                        // Remove this listener after first interaction
                        document.removeEventListener('click', unlockAudio);
                        document.removeEventListener('touchstart', unlockAudio);
                        sendButton.removeEventListener('click', unlockAudio); // Remove from send button too
                    }).catch(error => {
                        // Playback failed, likely due to user interaction requirement
                        console.error("Audio unlock failed:", error);
                        audioUnlocked = false; // Keep audio locked
                    });
                }
            } else if (audioUnlocked) {
                 console.log("Audio already unlocked.");
                 // Remove listeners if already unlocked
                 document.removeEventListener('click', unlockAudio);
                 document.removeEventListener('touchstart', unlockAudio);
                 sendButton.removeEventListener('click', unlockAudio); // Remove from send button too
            } else {
                 console.log("Notification sound not ready or not found.");
            }
        }


        // --- Custom Modal Helpers ---
        const lockOverlay = document.getElementById('lock-overlay');
        const passwordModal = document.getElementById('password-modal');
        const pwInput = document.getElementById('pw-modal-input');
        const pwError = document.getElementById('pw-modal-error');
        const pwTitle = document.getElementById('pw-modal-title');
        const promptModal = document.getElementById('prompt-modal');
        const promptInput = document.getElementById('prompt-modal-input');
        const promptTitle = document.getElementById('prompt-modal-title');
        const confirmModal = document.getElementById('confirm-modal');
        const confirmTitle = document.getElementById('confirm-modal-title');
        const confirmMessage = document.getElementById('confirm-modal-message');
        const lockChatButton = document.getElementById('lock-chat-button');

        // Show a password modal and return a promise that resolves true/false
        // Para palabra clave, usar caseInsensitive=true
        function showPasswordModal(title, correctPin, caseInsensitive = false){
            const pinToCheck = correctPin || CLEAR_CHAT_PASSWORD;
            return new Promise(resolve => {
                pwTitle.textContent = title || 'Ingresa la clave';
                pwInput.value = '';
                pwError.textContent = '';
                passwordModal.classList.add('active');
                pwInput.focus();

                function cleanup(){ passwordModal.classList.remove('active'); pwInput.removeEventListener('keypress', onKey); }
                function onKey(e){ if(e.key==='Enter') document.getElementById('pw-modal-ok').click(); }
                pwInput.addEventListener('keypress', onKey);

                document.getElementById('pw-modal-ok').onclick = () => {
                    let val = pwInput.value.trim();
                    let check = pinToCheck;
                    if (caseInsensitive) {
                        val = val.toLowerCase();
                        check = String(check).toLowerCase();
                    }
                    if(val === check){
                        cleanup(); resolve(true);
                    } else {
                        pwError.textContent = 'Clave incorrecta';
                        pwInput.value = '';
                        pwInput.focus();
                    }
                };
                document.getElementById('pw-modal-cancel').onclick = () => { cleanup(); resolve(false); };
            });
        }

        // Show a text prompt modal (replaces browser prompt)
        function showPromptModal(title, placeholder){
            return new Promise(resolve => {
                promptTitle.textContent = title || 'Ingresa un valor';
                promptInput.value = '';
                promptInput.placeholder = placeholder || '';
                promptModal.classList.add('active');
                promptInput.focus();

                function cleanup(){ promptModal.classList.remove('active'); promptInput.removeEventListener('keypress', onKey); }
                function onKey(e){ if(e.key==='Enter') document.getElementById('prompt-modal-ok').click(); }
                promptInput.addEventListener('keypress', onKey);

                document.getElementById('prompt-modal-ok').onclick = () => { const v = promptInput.value.trim(); cleanup(); resolve(v || null); };
                document.getElementById('prompt-modal-cancel').onclick = () => { cleanup(); resolve(null); };
            });
        }

        // Show a confirm modal and return a promise that resolves true/false
        function showConfirmModal(title, message){
            return new Promise(resolve => {
                confirmTitle.textContent = title || 'Confirmar';
                confirmMessage.textContent = message || '¿Deseas continuar?';
                confirmModal.classList.add('active');

                function cleanup(){ confirmModal.classList.remove('active'); }
                document.getElementById('confirm-modal-ok').onclick = () => { cleanup(); resolve(true); };
                document.getElementById('confirm-modal-cancel').onclick = () => { cleanup(); resolve(false); };
            });
        }


        // --- Lógica de BLOQUEO GLOBAL (Firebase RTDB) ---
        function setupChatLockListener(){
            chatLockRef.on('value', (snapshot) => {
                const data = snapshot.val();
                const isLocked = data && data.locked === true;
                if(isLocked){
                    lockOverlay.classList.add('active');
                    console.log('Chat bloqueado globalmente por:', data.lockedBy || 'desconocido');
                } else {
                    lockOverlay.classList.remove('active');
                    console.log('Chat desbloqueado.');
                }
            });
        }

        lockChatButton.addEventListener('click', () => {
            settingsDropdown.style.display = 'none';
            chatLockRef.set({ locked: true, lockedBy: userName || 'admin', lockedAt: firebase.database.ServerValue.TIMESTAMP })
                .then(() => console.log('Bloqueo activado globalmente'))
                .catch(err => console.error('Error al bloquear:', err));
        });

        // Ayuda = desbloquear con PIN del canal
        document.getElementById('lock-help-btn').addEventListener('click', async () => {
            if (!activeChannel) return;
            const channelConfigRef = database.ref(`channels/${activeChannel}/config`);
            const snapshot = await channelConfigRef.once('value');
            if (!snapshot.exists()) return;
            const config = snapshot.val();
            const ok = await showPasswordModal('Ingresa el PIN del canal para desbloquear', config.pin);
            if(ok){
                chatLockRef.set({ locked: false })
                    .then(() => console.log('Chat desbloqueado globalmente'))
                    .catch(err => console.error('Error al desbloquear:', err));
            }
        });

        // Más opciones = borrar chat con PIN del canal
        document.getElementById('lock-more-btn').addEventListener('click', async () => {
            if (!activeChannel) return;
            const channelConfigRef = database.ref(`channels/${activeChannel}/config`);
            const snapshot = await channelConfigRef.once('value');
            if (!snapshot.exists()) return;
            const config = snapshot.val();
            const ok = await showPasswordModal('Ingresa el PIN del canal para borrar el chat', config.pin);
            if(ok){
                try {
                    await messagesRef.remove();
                    console.log('Chat limpiado desde bloqueo');
                    clearChatUI();
                    await chatLockRef.set({ locked: false });
                } catch(err){ console.error('Error al limpiar chat:', err); }
            }
        });


        // --- Lógica para Limpiar Chat con PIN del Canal ---
        clearChatButton.addEventListener('click', async () => {
            settingsDropdown.style.display = 'none';
            if (!activeChannel) return;
            const channelConfigRef = database.ref(`channels/${activeChannel}/config`);
            const snapshot = await channelConfigRef.once('value');
            if (!snapshot.exists()) return;
            const config = snapshot.val();
            const ok = await showPasswordModal('Ingresa el PIN del canal para limpiar el chat', config.pin);
            if(ok){
                messagesRef.remove()
                    .then(() => {
                        console.log("Chat limpiado exitosamente en Realtime Database!");
                        clearChatUI();
                    })
                    .catch((error) => {
                        console.error("Error al limpiar el chat en Realtime Database:", error);
                    });
            }
        });

        // --- Lógica para Cambiar Nombre ---
        changeNameButton.addEventListener('click', async () => {
            settingsDropdown.style.display = 'none';
            const newName = await showPromptModal('Ingresa tu nuevo nombre', 'Nuevo nombre');
            if (newName && newName !== userName) {
                // Verificar si el nuevo nombre ya fue usado en este canal
                const nameTaken = await isNameTakenInChannel(newName, activeChannel);
                if (nameTaken) {
                    alert(`El nombre "${newName}" ya fue usado en este canal. Usa otro nombre o pide que limpien el chat para liberarlo.`);
                    return;
                }
                userName = newName;
                localStorage.setItem('chatName', userName);
                console.log(`Nombre cambiado a: ${userName}`);
                location.reload();
            }
        });

        // --- Lógica para Cambiar PIN del Canal (requiere Palabra Clave) ---
        document.getElementById('change-pin-button').addEventListener('click', async () => {
            settingsDropdown.style.display = 'none';
            if (!activeChannel) return;
            const channelConfigRef = database.ref(`channels/${activeChannel}/config`);
            const snapshot = await channelConfigRef.once('value');
            if (!snapshot.exists()) return;
            const config = snapshot.val();
            if (!config.keyword) {
                // Canal antiguo sin palabra clave, pedir PIN actual como fallback
                const ok = await showPasswordModal('Ingresa el PIN actual del canal', config.pin);
                if (!ok) return;
            } else {
                const ok = await showPasswordModal('Ingresa la Palabra Clave del canal', config.keyword, true);
                if (!ok) return;
            }
            const newPin = await showPromptModal('Ingresa el nuevo PIN', 'Nuevo PIN');
            if (!newPin) return;
            await channelConfigRef.update({ pin: newPin });
            showToast('🔑 PIN actualizado correctamente');
        });

        // --- Lógica para Cambiar Canal ---
        document.getElementById('change-channel-button').addEventListener('click', () => {
            settingsDropdown.style.display = 'none';
            localStorage.removeItem('chatChannel');
            location.reload();
        });

        // --- Lógica de Más opciones (Owner/Admin) ---
        document.getElementById('owner-options-button').addEventListener('click', async () => {
            settingsDropdown.style.display = 'none';
            if (!activeChannel) return;

            const channelConfigRef = database.ref(`channels/${activeChannel}/config`);
            const snapshot = await channelConfigRef.once('value');
            if (!snapshot.exists()) return;
            const config = snapshot.val();

            if (!config.keyword) {
                showToast('Este canal no tiene Palabra Clave configurada');
                return;
            }

            const ok = await showPasswordModal('Ingresa la Palabra Clave del canal', config.keyword, true);
            if (!ok) return;

            // Mostrar modal de opciones de admin
            const ownerModal = document.getElementById('owner-modal');
            const approvalToggle = document.getElementById('approval-toggle');
            const usersListDiv = document.getElementById('owner-users-list');

            // Cargar estado actual de aprobación
            approvalToggle.checked = config.requireApproval || false;

            // Estilo del toggle switch
            const toggleSlider = approvalToggle.nextElementSibling;
            toggleSlider.style.background = approvalToggle.checked ? '#007aff' : '#ccc';
            if (approvalToggle.checked) {
                toggleSlider.innerHTML = '<span style="position:absolute; right:4px; top:3px; width:18px; height:18px; background:white; border-radius:50%; transition:0.3s;"></span>';
            } else {
                toggleSlider.innerHTML = '<span style="position:absolute; left:4px; top:3px; width:18px; height:18px; background:white; border-radius:50%; transition:0.3s;"></span>';
            }

            // Toggle de aprobación
            approvalToggle.onchange = async () => {
                const newVal = approvalToggle.checked;
                toggleSlider.style.background = newVal ? '#007aff' : '#ccc';
                if (newVal) {
                    toggleSlider.innerHTML = '<span style="position:absolute; right:4px; top:3px; width:18px; height:18px; background:white; border-radius:50%; transition:0.3s;"></span>';
                } else {
                    toggleSlider.innerHTML = '<span style="position:absolute; left:4px; top:3px; width:18px; height:18px; background:white; border-radius:50%; transition:0.3s;"></span>';
                }
                await channelConfigRef.update({ requireApproval: newVal });
                showToast(newVal ? '🛡️ Aprobación de ingreso activada' : '🔓 Aprobación de ingreso desactivada');
            };

            // Cargar usuarios conectados
            const presSnap = await presenceRef.once('value');
            const onlineUsers = presSnap.val() || {};
            usersListDiv.innerHTML = '';

            Object.keys(onlineUsers).forEach(name => {
                if (onlineUsers[name] !== true) return;
                const userDiv = document.createElement('div');
                userDiv.style.cssText = 'display:flex; align-items:center; justify-content:space-between; padding:8px 10px; background:#fff; border:1px solid #e5e5ea; border-radius:6px; margin-bottom:6px;';
                const isCurrentUser = name === userName;
                userDiv.innerHTML = `
                    <span style="font-size:0.88em; font-weight:500;">${name}${isCurrentUser ? ' (tú)' : ''}</span>
                    ${!isCurrentUser ? `<button onclick="kickUser('${name.replace(/'/g, "\\'")}')" style="padding:4px 10px; background:#ff3b30; color:white; border:none; border-radius:6px; font-size:0.78em; cursor:pointer; font-weight:600;">👢 Expulsar</button>` : ''}
                `;
                usersListDiv.appendChild(userDiv);
            });

            if (Object.keys(onlineUsers).length === 0) {
                usersListDiv.innerHTML = '<p style="color:#888; font-size:0.85em; text-align:center;">No hay usuarios conectados</p>';
            }

            ownerModal.style.display = 'flex';
        });

        // Cerrar modal de admin
        document.getElementById('owner-modal-close').addEventListener('click', () => {
            document.getElementById('owner-modal').style.display = 'none';
        });

        // Función global para expulsar usuario
        window.kickUser = async function(targetName) {
            if (!activeChannel) return;
            await database.ref(`channels/${activeChannel}/kicked/${targetName}`).set({
                kickedBy: userName,
                timestamp: firebase.database.ServerValue.TIMESTAMP
            });
            // Eliminar presencia del usuario
            await presenceRef.child(targetName).remove();
            showToast(`👢 ${targetName} ha sido expulsado`);
            // Actualizar lista en el modal
            document.getElementById('owner-options-button').click();
        };

        // --- Listener de expulsión ---
        function setupKickedListener() {
            if (!activeChannel || !userName) return;
            const kickedRef = database.ref(`channels/${activeChannel}/kicked/${userName}`);
            kickedRef.on('value', (snap) => {
                if (snap.exists()) {
                    // El usuario fue expulsado
                    kickedRef.remove();
                    alert('Has sido expulsado del canal por el administrador.');
                    localStorage.removeItem('chatChannel');
                    location.reload();
                }
            });
        }

        // --- Lógica del Botón de Ayuda ---
        document.getElementById('help-btn').addEventListener('click', () => {
            const helpModal = document.getElementById('help-modal');
            helpModal.style.display = 'flex';
        });
        document.getElementById('help-modal-close').addEventListener('click', () => {
            document.getElementById('help-modal').style.display = 'none';
        });
        document.getElementById('help-modal').addEventListener('click', (e) => {
            if (e.target.id === 'help-modal') {
                document.getElementById('help-modal').style.display = 'none';
            }
        });


        // --- Lógica del Botón de Emoji y Selector ---

        // Lista de emojis para el selector
       const emojis = [
  // Caras y personas
  '😀', '😁', '😂', '🤣', '😃', '😄', '😅', '😆', '😉', '😊', '😋', '😎', '😍', '😘', '🥰', '😗', '😙', '😚', '☺️', '🙂', '🤗', '🤩', '🤔', '🤨', '😐', '😑', '😶', '🙄', '😏', '😣', '😥', '😮', '🤐', '😯', '😪', '😫', '🥱', '😴', '😌', '😛', '😜', '😝', '🤤', '😒', '😓', '😔', '😕', '🙃', '🤑', '😲', '☹️', '🙁', '😖', '😞', '😟', '😤', '😢', '😭', '😦', '😧', '😨', '😩', '🤯', '😬', '😰', '😱', '🥵', '🥶', '😳', '🤪', '😵', '🥴', '😠', '😡', '🤬', '😷', '🤒', '🤕', '🤢', '🤮', '🤧', '😇', '🥳', '🥺', '🤠', '🤡', '🥳', '🤫', '🤭', '🧐', '🤓', '😈', '👿', '👹', '👺', '💀', '👻', '👽', '🤖', '💩',
  // Corazones y gestos
  '😺', '😸', '😹', '😻', '😼', '😽', '🙀', '😿', '😾', '🙈', '🙉', '🙊', '💋', '💌', '💘', '💝', '💖', '💗', '💓', '💞', '💕', '💟', '❣️', '💔', '❤️', '🧡', '💛', '💚', '💙', '💜', '🤎', '🖤', '🤍', '💯', '💢', '💥', '💫', '💦', '💨', '🕳️', '💣', '💬', '👁️‍🗨️', '🗨️', '🗯️', '💭', '💤', '👋', '🤚', '🖐️', '✋', '🖖', '👌', '🤏', '✌️', '🤞', '🤟', '🤘', '🤙', '👈', '👉', '👆', '🖕', '👇', '☝️', '👍', '👎', '✊', '👊', '🤛', '🤜', '👏', '🙌', '👐', '🤲', '🤝', '🙏'
];

        // Llenar el selector de emojis
        emojis.forEach(emoji => {
            const emojiSpan = document.createElement('span');
            emojiSpan.textContent = emoji;
            emojiPicker.appendChild(emojiSpan);

            // Añadir listener para insertar el emoji en el input
            emojiSpan.addEventListener('click', () => {
                insertEmoji(emoji);
                // Opcional: Ocultar el selector después de seleccionar un emoji
                // emojiPicker.style.display = 'none';
            });
        });

        // Función para insertar emoji en el textarea en la posición del cursor
        function insertEmoji(emoji) {
            const textarea = messageInput;
            const start = textarea.selectionStart;
            const end = textarea.selectionEnd;
            const value = textarea.value;

            textarea.value = value.substring(0, start) + emoji + value.substring(end);

            // Mover el cursor después del emoji insertado
            textarea.selectionStart = textarea.selectionEnd = start + emoji.length;

            // Disparar un evento 'input' para que la lógica de auto-ajuste de altura y typing indicator se active
            const event = new Event('input', { bubbles: true });
            textarea.dispatchEvent(event);

            textarea.focus(); // Mantener el foco en el textarea
        }


        // Listener para el botón de emoji para mostrar/ocultar el selector
        emojiButton.addEventListener('click', (event) => {
            // Prevenir que el clic en el botón cierre el selector inmediatamente
            event.stopPropagation();
             // Ocultar el dropdown de settings si está visible
             settingsDropdown.style.display = 'none';

            if (emojiPicker.style.display === 'flex') {
                emojiPicker.style.display = 'none';
            } else {
                // Posicionar el selector justo encima de la barra de input
                // bottom del selector = altura del área de input + padding/margen
                const inputAreaHeight = bottomFixedArea.offsetHeight; // Usar la altura del contenedor fijo
                emojiPicker.style.bottom = `${inputAreaHeight + 10}px`; // 10px de margen
                emojiPicker.style.display = 'flex';
            }
        });

        // Ocultar el selector de emojis y el dropdown de settings si se hace clic fuera de ellos
        document.addEventListener('click', (event) => {
            // Si el clic no fue dentro del selector de emojis ni en el botón de emoji
            if (!emojiPicker.contains(event.target) && event.target !== emojiButton) {
                emojiPicker.style.display = 'none';
            }
             // Si el clic no fue dentro del dropdown de settings ni en el botón de settings
             if (!settingsDropdown.contains(event.target) && event.target !== settingsButton) {
                 settingsDropdown.style.display = 'none';
             }
        });


        // --- Lógica para Ajustar Layout con Teclado Virtual ---

        // Función para ajustar el padding inferior del chatBox
        function adjustChatBoxPadding() {
            // Usar un pequeño retraso para asegurar que el DOM esté renderizado y las alturas sean correctas
            setTimeout(() => {
                 // Usar la altura del nuevo contenedor fijo
                 const bottomAreaHeight = bottomFixedArea.offsetHeight;
                 // Añadir un buffer más grande para asegurar espacio suficiente
                 // Puedes ajustar este valor (80) para aumentar o disminuir el espacio inferior
                 const newPaddingBottom = bottomAreaHeight + 10; // Buffer mínimo para que quede pegado
                 chatBox.style.paddingBottom = `${newPaddingBottom}px`;
                 console.log(`[${userName}] Adjusted paddingBottom of chatBox to ${chatBox.style.paddingBottom}`); // Debugging log con nombre de usuario
                 console.log(`[${userName}] bottomFixedArea.offsetHeight: ${bottomAreaHeight}`); // Debugging log con nombre de usuario
                 // Intentar scrollear al final después de ajustar el padding
                 chatBox.scrollTop = chatBox.scrollHeight;
            }, 300); // Aumentar el retraso a 300ms
        }


        // Listener para el evento resize de la ventana
        window.addEventListener('resize', adjustChatBoxPadding);

        // Listener para el evento 'focus' en el input de mensaje
        messageInput.addEventListener('focus', () => {
             // Intentar scrollear la caja de chat al final cuando el input recibe foco
             // Esto ayuda a asegurar que la barra de input sea visible
             setTimeout(() => {
                 chatBox.scrollTop = chatBox.scrollHeight;
                 console.log(`[${userName}] Input enfocado, scrolleando chatBox al final con retraso.`); // Debugging log con nombre de usuario
             }, 150); // Retraso para dar tiempo al layout a ajustarse
        });


        // --- Lógica de Editar Mensajes ---
        function startEdit(messageId, currentText) {
            // Cancelar cualquier modo de respuesta activo
            cancelReply();
            // Guardar datos del mensaje que se está editando
            editingMessageId = messageId;
            editingMessageText = currentText;
            // Cargar el texto actual en el input
            messageInput.value = currentText;
            // Mostrar la vista previa de edición
            editTextSpan.textContent = currentText;
            editPreview.style.display = 'flex';
            // Ajustar altura del textarea y padding
            adjustTextareaHeight();
            adjustChatBoxPadding();
            // Poner foco en el input y seleccionar todo el texto
            messageInput.focus();
            messageInput.select();
        }

        function cancelEdit() {
            editingMessageId = null;
            editingMessageText = null;
            editPreview.style.display = 'none';
            editTextSpan.textContent = '';
            messageInput.value = '';
            messageInput.style.height = 'auto';
            adjustChatBoxPadding();
        }

        // Listener para el botón de cancelar edición
        cancelEditButton.addEventListener('click', cancelEdit);

        // --- Lógica de Responder Mensajes ---

        // Función para iniciar el modo de respuesta
        function startReply(messageData) {
            replyingToMessage = messageData; // Almacenar los datos del mensaje
            replyNameSpan.textContent = messageData.name + ':';
            // Mostrar un fragmento del texto o indicar que es un archivo
            replyTextSpan.textContent = messageData.text ? messageData.text.substring(0, 50) + (messageData.text.length > 50 ? '...' : '') : 'Archivo'; // Asumiendo solo texto por ahora

            replyPreview.style.display = 'flex'; // Mostrar la vista previa
            messageInput.focus(); // Poner el foco en el campo de mensaje
            // Ajustar padding después de mostrar la vista previa
            adjustChatBoxPadding();
        }

        // Función para cancelar el modo de respuesta
        function cancelReply() {
            replyingToMessage = null; // Limpiar la referencia al mensaje
            replyPreview.style.display = 'none'; // Ocultar la vista previa
            replyNameSpan.textContent = '';
            replyTextSpan.textContent = '';
            // Ajustar padding después de ocultar la vista previa
            adjustChatBoxPadding();
        }

        // Listener para el botón de cancelar respuesta
        cancelReplyButton.addEventListener('click', cancelReply);


        // --- Lógica del Botón de Configuración y Dropdown ---

        // Listener para el botón de configuración para mostrar/ocultar el dropdown
        settingsButton.addEventListener('click', (event) => {
            // Prevenir que el clic en el botón cierre el dropdown inmediatamente
            event.stopPropagation();
             // Ocultar el selector de emojis si está visible
             emojiPicker.style.display = 'none';

            if (settingsDropdown.style.display === 'flex') {
                settingsDropdown.style.display = 'none';
            } else {
                // Posicionar el dropdown justo debajo y a la derecha del botón de settings
                // Esto se maneja principalmente con CSS position: absolute y top/right
                settingsDropdown.style.display = 'flex';
                // La posición top y right ya están definidas en CSS, pero podrías ajustarlas dinámicamente si fuera necesario
                // const settingsButtonRect = settingsButton.getBoundingClientRect();
                // settingsDropdown.style.top = `${settingsButtonRect.bottom + 5}px`; // 5px debajo del botón
                // settingsDropdown.style.right = `${window.innerWidth - settingsButtonRect.right}px`; // Alinear a la derecha del botón
            }
        });


        // --- Lógica de Presencia (Usuarios en Línea) ---
        function setupPresence() {
             if (!userName) return;

             const userPresenceRef = presenceRef.child(userName);
             const connectedRef = database.ref('.info/connected');

             // Patrón oficial de Firebase: escuchar estado de conexión
             connectedRef.on('value', (snap) => {
                 if (snap.val() === true) {
                     // Cada vez que Firebase reconecta, re-registrar onDisconnect
                     userPresenceRef.onDisconnect().remove()
                         .then(() => {
                             // Solo marcar presencia DESPUÉS de que onDisconnect esté listo
                             userPresenceRef.set(true);
                             console.log(`[${userName}] Conectado. Presencia activada.`);
                         })
                         .catch(error => console.error(`[${userName}] Error configuring onDisconnect:`, error));
                 }
             });

             // Limpieza al cerrar pestaña (respaldo)
             window.addEventListener('beforeunload', () => {
                 userPresenceRef.remove();
             });


             // Escuchar cambios en el nodo de presencia para actualizar la lista de usuarios en línea
             presenceRef.on('value', (snapshot) => {
                 const onlineUsers = snapshot.val();
                 const usersOnline = [];

                 if (onlineUsers) {
                     for (const name in onlineUsers) {
                         if (onlineUsers[name] === true && name !== userName) {
                             usersOnline.push(name);
                         }
                     }
                 }

                 if (usersOnline.length > 0) {
                     onlineUsersDiv.textContent = `En línea: ${usersOnline.join(', ')}`;
                 } else {
                     onlineUsersDiv.textContent = 'Nadie más en línea';
                 }
                 console.log(`[${userName}] Online users updated: ${onlineUsersDiv.textContent}. Raw data:`, onlineUsers);
             }, (error) => {
                 console.error(`[${userName}] Error in presence listener:`, error);
             });
        }


        // Comprobar si hay un nombre guardado en localStorage al cargar la página
        const savedName = localStorage.getItem('chatName');
        const savedChannelValue = localStorage.getItem('chatChannel');
        if (savedName) {
            nameInput.value = savedName;
        }
        if (savedChannelValue) {
            channelInput.value = savedChannelValue;
        }

        // Ajustes iniciales al cargar la página
        window.onload = async function() {
             // Si hay un nombre y canal guardados, inicializar el chat
             const savedChannel = localStorage.getItem('chatChannel');
             if (localStorage.getItem('chatName') && savedChannel) {
                 const savedName = localStorage.getItem('chatName');
                 // Verificar que el nombre no haya sido tomado por otra persona
                 // (solo bloquear si hay mensajes de ese nombre Y el usuario no es quien los escribió previamente)
                 // En auto-login el usuario ya estaba en el canal, así que se permite re-entrar con su mismo nombre
                 userName = savedName;
                 activeChannel = savedChannel;
                 setupChannelRefs(activeChannel);
                 namePrompt.style.display = 'none';
                 chatInterface.style.display = 'flex';
                 document.getElementById('chat-title').textContent = activeChannel;
                 initializeChat();
             }
             // Ajustar el padding inferior del chatBox al cargar
             adjustChatBoxPadding();

             // Add initial click/touch listeners to unlock audio
             document.addEventListener('click', unlockAudio, { once: true });
             document.addEventListener('touchstart', unlockAudio, { once: true });
             sendButton.addEventListener('click', unlockAudio, { once: true }); // Also try on send button click


        };

        // --- Registro del Service Worker para PWA ---
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('./sw-chat.js')
                .then(reg => console.log('Service Worker registrado:', reg.scope))
                .catch(err => console.error('Error al registrar Service Worker:', err));
        }

        // --- Lógica de instalación PWA (Android + iOS) ---
        let deferredInstallPrompt = null;
        const installBtn = document.getElementById('install-app-button');
        const iosBanner = document.getElementById('ios-install-banner');
        const iosBackdrop = document.getElementById('ios-install-backdrop');
        const iosBannerClose = document.getElementById('ios-banner-close');

        // Detectar iOS Safari (no standalone, no Chrome, no Firefox)
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        const isIOSSafari = isIOS && /Safari/i.test(navigator.userAgent) && !/CriOS|FxiOS|OPiOS|EdgiOS/i.test(navigator.userAgent);
        const isIOSStandalone = window.navigator.standalone === true;

        function showIOSBanner() {
            iosBanner.classList.add('show');
            iosBackdrop.classList.add('show');
        }
        function hideIOSBanner() {
            iosBanner.classList.remove('show');
            iosBackdrop.classList.remove('show');
        }
        iosBannerClose.addEventListener('click', () => {
            hideIOSBanner();
            localStorage.setItem('ios-install-dismissed', 'true');
        });
        iosBackdrop.addEventListener('click', hideIOSBanner);

        // Android / Chrome: beforeinstallprompt
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredInstallPrompt = e;
            installBtn.style.display = 'block';
            installBtn.textContent = '📲 Instalar App';
            console.log('PWA install prompt available');
        });

        // iOS Safari: mostrar botón de instalar con guía
        if (isIOSSafari && !isIOSStandalone) {
            installBtn.style.display = 'block';
            installBtn.textContent = '📲 Instalar en iPhone';

            // Auto-mostrar banner la primera vez
            if (!localStorage.getItem('ios-install-dismissed')) {
                setTimeout(showIOSBanner, 2000);
            }
        }

        installBtn.addEventListener('click', async () => {
            settingsDropdown.style.display = 'none';
            if (deferredInstallPrompt) {
                // Android/Chrome flow
                deferredInstallPrompt.prompt();
                const result = await deferredInstallPrompt.userChoice;
                console.log('Install result:', result.outcome);
                deferredInstallPrompt = null;
                installBtn.style.display = 'none';
            } else if (isIOSSafari && !isIOSStandalone) {
                // iOS flow: mostrar banner con instrucciones
                showIOSBanner();
            }
        });

        window.addEventListener('appinstalled', () => {
            console.log('PWA installed successfully');
            installBtn.style.display = 'none';
            deferredInstallPrompt = null;
        });

        // =============================================
        // === ENVIAR IMÁGENES (comprimir + base64) ===
        // =============================================
        const imageButton = document.getElementById('image-button');
        const imageInput = document.getElementById('image-input');

        imageButton.addEventListener('click', () => imageInput.click());

        // --- Lightbox para imágenes ---
        (function() {
            const lb = document.getElementById('image-lightbox');
            const lbImg = document.getElementById('lightbox-img');
            const lbClose = document.getElementById('lightbox-close');
            const lbDownload = document.getElementById('lightbox-download');
            lbClose.addEventListener('click', () => lb.classList.remove('active'));
            lb.addEventListener('click', (e) => { if (e.target === lb) lb.classList.remove('active'); });
            lbDownload.addEventListener('click', (e) => {
                e.stopPropagation();
                const a = document.createElement('a');
                a.href = lbImg.src;
                a.download = 'ichat_imagen.jpg';
                a.click();
            });
        })();

        // --- Compartir link (Copiar / Share) ---
        (function() {
            const linkEl = document.getElementById('share-link-url');
            const copyBtn = document.getElementById('copy-link-btn');
            const shareBtn = document.getElementById('share-link-btn');
            if (!linkEl || !copyBtn || !shareBtn) return;
            const link = linkEl.textContent.trim();

            copyBtn.addEventListener('click', async () => {
                try {
                    if (navigator.clipboard && navigator.clipboard.writeText) {
                        await navigator.clipboard.writeText(link);
                    } else {
                        const tmp = document.createElement('textarea');
                        tmp.value = link;
                        tmp.style.position = 'fixed';
                        tmp.style.left = '-9999px';
                        document.body.appendChild(tmp);
                        tmp.select();
                        document.execCommand('copy');
                        tmp.remove();
                    }
                    showToast('✅ Link copiado. ¡Compártelo con tus amigos!');
                } catch (e) {
                    console.error('Error al copiar link:', e);
                    alert('No se pudo copiar el link. Cópialo manualmente: ' + link);
                }
            });

            shareBtn.addEventListener('click', async () => {
                try {
                    if (navigator.share) {
                        await navigator.share({
                            title: 'Ichatmsn',
                            text: 'Únete a mi canal en Ichatmsn:',
                            url: 'https://www.tinyurl.com/ichatmsn'
                        });
                    } else {
                        // Fallback: copiar
                        copyBtn.click();
                    }
                } catch (e) {
                    // Si cancelan el share sheet, no mostrar error
                    console.warn('Share cancelado o falló:', e);
                }
            });
        })();

        // --- Zumbido / Nudge (MSN Messenger style) ---
        let lastNudgeTime = 0;
        const NUDGE_COOLDOWN = 5000; // 5 segundos entre zumbidos

        function triggerNudgeEffect() {
            // Shake the chat container (3 seconds = 0.375s * 8 repeats)
            const chatContainer = document.getElementById('chat-container');
            chatContainer.classList.add('nudge-shaking');
            setTimeout(() => chatContainer.classList.remove('nudge-shaking'), 3000);
            // Vibrar fuerte en dispositivos móviles (3 segundos de patrón)
            if (navigator.vibrate) {
                navigator.vibrate([200, 80, 200, 80, 200, 80, 200, 80, 200, 80, 200, 80, 200, 80, 200]);
            }
            // Sonido tipo MSN Messenger Nudge — fuerte, ruidoso, ~3 segundos
            // Basado en el sonido original del Windows Live Messenger "buzz"
            try {
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const t = ctx.currentTime;
                const duration = 3.0;

                // Master volume — FUERTE
                const master = ctx.createGain();
                master.gain.setValueAtTime(0.7, t);
                master.connect(ctx.destination);

                // Compressor para que suene más fuerte sin distorsionar
                const compressor = ctx.createDynamicsCompressor();
                compressor.threshold.setValueAtTime(-10, t);
                compressor.knee.setValueAtTime(10, t);
                compressor.ratio.setValueAtTime(8, t);
                compressor.attack.setValueAtTime(0.003, t);
                compressor.release.setValueAtTime(0.1, t);
                compressor.connect(master);

                // Buzz principal — onda cuadrada con vibrato rápido (el sonido "eléctrico" del MSN)
                for (let i = 0; i < 6; i++) {
                    const startTime = t + (i * 0.5);
                    const buzzDur = 0.45;

                    // Tono bajo buzz
                    const buzz = ctx.createOscillator();
                    const buzzGain = ctx.createGain();
                    buzz.type = 'square';
                    buzz.frequency.setValueAtTime(220, startTime);
                    buzz.frequency.setValueAtTime(185, startTime + 0.1);
                    buzz.frequency.setValueAtTime(220, startTime + 0.2);
                    buzz.frequency.setValueAtTime(185, startTime + 0.3);
                    buzzGain.gain.setValueAtTime(0.3, startTime);
                    buzzGain.gain.setValueAtTime(0.25, startTime + buzzDur * 0.5);
                    buzzGain.gain.exponentialRampToValueAtTime(0.01, startTime + buzzDur);
                    buzz.connect(buzzGain);
                    buzzGain.connect(compressor);
                    buzz.start(startTime);
                    buzz.stop(startTime + buzzDur);

                    // Tono agudo resonante (el "ring" metálico del MSN)
                    const ring = ctx.createOscillator();
                    const ringGain = ctx.createGain();
                    ring.type = 'sawtooth';
                    ring.frequency.setValueAtTime(880, startTime);
                    ring.frequency.setValueAtTime(740, startTime + 0.15);
                    ring.frequency.setValueAtTime(880, startTime + 0.3);
                    ringGain.gain.setValueAtTime(0.12, startTime);
                    ringGain.gain.exponentialRampToValueAtTime(0.01, startTime + buzzDur);
                    ring.connect(ringGain);
                    ringGain.connect(compressor);
                    ring.start(startTime);
                    ring.stop(startTime + buzzDur);

                    // Sub-bass punch (golpe de cada ciclo)
                    const sub = ctx.createOscillator();
                    const subGain = ctx.createGain();
                    sub.type = 'sine';
                    sub.frequency.setValueAtTime(100, startTime);
                    sub.frequency.exponentialRampToValueAtTime(50, startTime + 0.15);
                    subGain.gain.setValueAtTime(0.4, startTime);
                    subGain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.2);
                    sub.connect(subGain);
                    subGain.connect(compressor);
                    sub.start(startTime);
                    sub.stop(startTime + 0.2);
                }

                // Ruido blanco de fondo (textura de "interferencia")
                const noiseLen = ctx.sampleRate * duration;
                const noiseBuf = ctx.createBuffer(1, noiseLen, ctx.sampleRate);
                const noiseData = noiseBuf.getChannelData(0);
                for (let i = 0; i < noiseLen; i++) {
                    noiseData[i] = (Math.random() * 2 - 1) * 0.15;
                }
                const noiseSource = ctx.createBufferSource();
                noiseSource.buffer = noiseBuf;
                const noiseGain = ctx.createGain();
                noiseGain.gain.setValueAtTime(0.08, t);
                noiseGain.gain.setValueAtTime(0.12, t + 0.5);
                noiseGain.gain.setValueAtTime(0.08, t + 1.5);
                noiseGain.gain.exponentialRampToValueAtTime(0.01, t + duration);
                // Filtro paso banda para el ruido
                const noiseFilter = ctx.createBiquadFilter();
                noiseFilter.type = 'bandpass';
                noiseFilter.frequency.setValueAtTime(1200, t);
                noiseFilter.Q.setValueAtTime(2, t);
                noiseSource.connect(noiseFilter);
                noiseFilter.connect(noiseGain);
                noiseGain.connect(compressor);
                noiseSource.start(t);
                noiseSource.stop(t + duration);

                setTimeout(() => ctx.close(), (duration + 0.5) * 1000);
            } catch(e) { console.warn('No se pudo reproducir sonido de zumbido:', e); }
        }

        document.getElementById('nudge-button').addEventListener('click', () => {
            if (!userName || !messagesRef) return;
            const now = Date.now();
            if (now - lastNudgeTime < NUDGE_COOLDOWN) {
                const secsLeft = Math.ceil((NUDGE_COOLDOWN - (now - lastNudgeTime)) / 1000);
                showToast(`⚡ Espera ${secsLeft}s para enviar otro zumbido`);
                return;
            }
            lastNudgeTime = now;
            messagesRef.push({
                name: userName,
                type: 'nudge',
                timestamp: firebase.database.ServerValue.TIMESTAMP,
                status: 'sent',
                sid: sessionId
            });
            // Efecto local también
            triggerNudgeEffect();
            showToast('⚡ ¡Zumbido enviado!');
        });

        // Toast de notificación
        function showToast(message, duration = 3500) {
            let toast = document.querySelector('.toast-notification');
            if (!toast) {
                toast = document.createElement('div');
                toast.classList.add('toast-notification');
                document.body.appendChild(toast);
            }
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), duration);
        }

        // Limpieza automática de imágenes, videos y documentos expirados (>24h)
        function cleanupExpiredMedia() {
            if (!messagesRef) return;
            const cutoff = Date.now() - (24 * 60 * 60 * 1000);
            messagesRef.orderByChild('timestamp').endAt(cutoff).once('value', (snap) => {
                const updates = {};
                snap.forEach(child => {
                    const msg = child.val();
                    if (msg.type === 'image' && msg.imageData) {
                        updates[`${child.key}/imageData`] = null;
                    }
                    if (msg.type === 'video' && msg.videoData) {
                        updates[`${child.key}/videoData`] = null;
                    }
                    if (msg.type === 'document' && msg.docData) {
                        updates[`${child.key}/docData`] = null;
                    }
                });
                if (Object.keys(updates).length > 0) {
                    messagesRef.update(updates).then(() => {
                        console.log(`Cleaned ${Object.keys(updates).length} expired media items`);
                    });
                }
            });
        }
        // Ejecutar limpieza cada 5 minutos y al iniciar
        setInterval(cleanupExpiredMedia, 5 * 60 * 1000);

        imageInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            imageInput.value = ''; // Reset para permitir re-selección

            showToast('⏳ Las imágenes se borran después de 24 horas. Guárdala con 💾 si la necesitas.');

            try {
                const base64 = await compressAndEncode(file, 800, 0.6);
                const newMessage = {
                    name: userName,
                    type: 'image',
                    imageData: base64,
                    timestamp: Date.now(),
                    status: 'sent',
                    sid: sessionId
                };
                if (replyingToMessage) {
                    newMessage.replyTo = { id: replyingToMessage.id, name: replyingToMessage.name, text: replyingToMessage.text };
                    cancelReply();
                }
                messagesRef.push(newMessage);
            } catch (err) {
                console.error('Error al enviar imagen:', err);
                alert('Error al procesar la imagen');
            }
        });

        function compressAndEncode(file, maxSize, quality) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        let w = img.width, h = img.height;
                        if (w > maxSize || h > maxSize) {
                            if (w > h) { h = Math.round(h * maxSize / w); w = maxSize; }
                            else { w = Math.round(w * maxSize / h); h = maxSize; }
                        }
                        canvas.width = w;
                        canvas.height = h;
                        canvas.getContext('2d').drawImage(img, 0, 0, w, h);
                        resolve(canvas.toDataURL('image/jpeg', quality));
                    };
                    img.onerror = reject;
                    img.src = e.target.result;
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        // =============================================
        // === ENVIAR VIDEOS (comprimir + base64)   ===
        // =============================================
        const videoButton = document.getElementById('video-button');
        const videoInput = document.getElementById('video-input');
        videoButton.addEventListener('click', () => videoInput.click());

        function compressVideo(file, maxSizeMB) {
            return new Promise((resolve, reject) => {
                const MAX_BYTES = (maxSizeMB || 4) * 1024 * 1024;
                // Si es pequeño, enviar directo como base64
                if (file.size <= MAX_BYTES) {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(file);
                    return;
                }

                // Comprimir reduciendo resolución y bitrate
                const video = document.createElement('video');
                video.muted = true;
                video.playsInline = true;
                video.src = URL.createObjectURL(file);

                video.onloadedmetadata = () => {
                    const duration = video.duration;
                    let w = video.videoWidth, h = video.videoHeight;
                    // Reducir resolución
                    const maxDim = 480;
                    if (w > maxDim || h > maxDim) {
                        if (w > h) { h = Math.round(h * maxDim / w); w = maxDim; }
                        else { w = Math.round(w * maxDim / h); h = maxDim; }
                    }

                    const canvas = document.createElement('canvas');
                    canvas.width = w;
                    canvas.height = h;
                    const ctx = canvas.getContext('2d');

                    // Calcular bitrate para que quepa en el límite
                    const targetBits = MAX_BYTES * 8 * 0.85; // 85% del máximo
                    const videoBitrate = Math.min(800000, Math.floor(targetBits / Math.max(duration, 1)));

                    let stream;
                    try {
                        stream = canvas.captureStream(24);
                    } catch(e) {
                        // Fallback: enviar sin comprimir si captureStream no disponible
                        const reader = new FileReader();
                        reader.onload = () => resolve(reader.result);
                        reader.onerror = reject;
                        reader.readAsDataURL(file);
                        return;
                    }

                    const mimeType = MediaRecorder.isTypeSupported('video/webm;codecs=vp8') ? 'video/webm;codecs=vp8' : 'video/webm';
                    const recorder = new MediaRecorder(stream, { mimeType, videoBitsPerSecond: videoBitrate });
                    const chunks = [];
                    recorder.ondataavailable = (e) => { if (e.data.size > 0) chunks.push(e.data); };
                    recorder.onstop = () => {
                        const blob = new Blob(chunks, { type: mimeType });
                        const reader = new FileReader();
                        reader.onload = () => {
                            URL.revokeObjectURL(video.src);
                            resolve(reader.result);
                        };
                        reader.onerror = reject;
                        reader.readAsDataURL(blob);
                    };

                    recorder.start();
                    video.currentTime = 0;
                    video.play();

                    const drawFrame = () => {
                        if (video.ended || video.paused) {
                            recorder.stop();
                            stream.getTracks().forEach(t => t.stop());
                            return;
                        }
                        ctx.drawImage(video, 0, 0, w, h);
                        requestAnimationFrame(drawFrame);
                    };
                    video.onplay = drawFrame;
                    video.onended = () => {
                        setTimeout(() => {
                            if (recorder.state === 'recording') recorder.stop();
                            stream.getTracks().forEach(t => t.stop());
                        }, 100);
                    };
                };
                video.onerror = () => reject(new Error('Error al cargar video'));
            });
        }

        // Banner persistente para subida de video
        function showUploadBanner(text) {
            removeUploadBanner();
            const banner = document.createElement('div');
            banner.classList.add('upload-banner');
            banner.id = 'upload-banner';
            banner.innerHTML = `<div class="upload-spinner"></div><span>${text}</span>`;
            document.body.appendChild(banner);
        }
        function updateUploadBanner(text) {
            const banner = document.getElementById('upload-banner');
            if (banner) banner.querySelector('span').textContent = text;
        }
        function removeUploadBanner() {
            const banner = document.getElementById('upload-banner');
            if (banner) banner.remove();
        }

        videoInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            videoInput.value = '';

            if (file.size > 50 * 1024 * 1024) {
                alert('El video es muy grande. Máximo 50 MB.');
                return;
            }

            showToast('⏳ Los videos se borran después de 24 horas. Guárdalo con 💾 si lo necesitas.');
            showUploadBanner('📹 Procesando video… no cierres el chat');

            try {
                const base64 = await compressVideo(file, 4);
                updateUploadBanner('📤 Enviando video…');
                const newMessage = {
                    name: userName,
                    type: 'video',
                    videoData: base64,
                    timestamp: Date.now(),
                    status: 'sent',
                    sid: sessionId
                };
                if (replyingToMessage) {
                    newMessage.replyTo = { id: replyingToMessage.id, name: replyingToMessage.name, text: replyingToMessage.text };
                    cancelReply();
                }
                await messagesRef.push(newMessage);
                removeUploadBanner();
                showToast('✅ Video enviado correctamente');
            } catch (err) {
                removeUploadBanner();
                console.error('Error al enviar video:', err);
                alert('Error al procesar el video');
            }
        });

        // =============================================
        // === ENVIAR DOCUMENTOS (base64 temporal)  ===
        // =============================================
        const docButton = document.getElementById('doc-button');
        const docInput = document.getElementById('doc-input');
        docButton.addEventListener('click', () => docInput.click());

        docInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            docInput.value = '';

            if (file.size > 5 * 1024 * 1024) {
                alert('El documento es muy grande. Máximo 5 MB.');
                return;
            }

            showToast('⏳ Los documentos se borran después de 24 horas. Descárgalo si lo necesitas.');

            try {
                const base64 = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(file);
                });

                const newMessage = {
                    name: userName,
                    type: 'document',
                    docData: base64,
                    docName: file.name,
                    docSize: file.size,
                    timestamp: Date.now(),
                    status: 'sent',
                    sid: sessionId
                };
                if (replyingToMessage) {
                    newMessage.replyTo = { id: replyingToMessage.id, name: replyingToMessage.name, text: replyingToMessage.text };
                    cancelReply();
                }
                messagesRef.push(newMessage);
            } catch (err) {
                console.error('Error al enviar documento:', err);
                alert('Error al procesar el documento');
            }
        });

        // =============================================
        // === GRABAR NOTAS DE VOZ (MediaRecorder)  ===
        // =============================================
        const micButton = document.getElementById('mic-button');
        const micCancelButton = document.getElementById('mic-cancel-button');
        let mediaRecorder = null;
        let audioChunks = [];
        let isRecording = false;
        let audioCancelled = false;

        const MIC_ICON = '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg>';
        const STOP_ICON = '<svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><rect x="6" y="6" width="12" height="12" rx="2"/></svg>';

        micButton.addEventListener('click', async () => {
            if (isRecording) {
                audioCancelled = false;
                stopRecording();
            } else {
                startRecording();
            }
        });

        micCancelButton.addEventListener('click', () => {
            if (isRecording) {
                audioCancelled = true;
                stopRecording();
                showToast('🗑️ Audio descartado');
            }
        });

        async function startRecording() {
            try {
                audioCancelled = false;
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm;codecs=opus' });
                audioChunks = [];

                mediaRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0) audioChunks.push(e.data);
                };

                mediaRecorder.onstop = async () => {
                    stream.getTracks().forEach(t => t.stop());
                    if (audioCancelled) return;
                    const blob = new Blob(audioChunks, { type: 'audio/webm' });
                    const reader = new FileReader();
                    reader.onload = () => {
                        const base64 = reader.result;
                        const newMessage = {
                            name: userName,
                            type: 'audio',
                            audioData: base64,
                            timestamp: Date.now(),
                            status: 'sent',
                            sid: sessionId
                        };
                        messagesRef.push(newMessage);
                    };
                    reader.readAsDataURL(blob);
                };

                mediaRecorder.start();
                isRecording = true;
                micButton.classList.add('recording');
                micButton.innerHTML = STOP_ICON;
                micCancelButton.classList.add('visible');
            } catch (err) {
                console.error('Error al acceder al micrófono:', err);
                alert('No se pudo acceder al micrófono');
            }
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }
            isRecording = false;
            micButton.classList.remove('recording');
            micButton.innerHTML = MIC_ICON;
            micCancelButton.classList.remove('visible');
        }

        // =============================================
        // === LLAMADAS GRUPALES WebRTC + Firebase    ===
        // =============================================
        const voiceCallBtn = document.getElementById('voice-call-button');
        const videoCallBtn = document.getElementById('video-call-button');
        const callOverlay = document.getElementById('call-overlay');
        const callStatusEl = document.getElementById('call-status');
        const callPeerNameEl = document.getElementById('call-peer-name');
        const callTimerEl = document.getElementById('call-timer');
        const callVideoGrid = document.getElementById('call-video-grid');
        const localVideo = document.getElementById('local-video');
        const endCallBtn = document.getElementById('end-call-btn');
        const acceptCallBtn = document.getElementById('accept-call-btn');
        const rejectCallBtn = document.getElementById('reject-call-btn');
        const callActionsOutgoing = document.getElementById('call-actions-outgoing');
        const callActionsIncoming = document.getElementById('call-actions-incoming');
        const flipCameraBtn = document.getElementById('flip-camera-btn');
        const speakerBtn = document.getElementById('speaker-btn');
        let speakerEnabled = false;
        let remoteAudioElements = {};

        // --- Altavoz / Speaker toggle ---
        speakerBtn.addEventListener('click', () => {
            speakerEnabled = !speakerEnabled;
            speakerBtn.classList.toggle('speaker-on', speakerEnabled);
            speakerBtn.classList.toggle('speaker-off', !speakerEnabled);
            speakerBtn.title = speakerEnabled ? 'Altavoz activado' : 'Altavoz desactivado';
            // Intentar cambiar el audio output si está disponible
            Object.values(remoteAudioElements).forEach(audioEl => {
                if (audioEl.setSinkId) {
                    // Nota: setSinkId requiere permisos y no siempre está disponible
                    console.log('Intentando cambiar audio output...');
                }
            });
            showToast(speakerEnabled ? '🔊 Altavoz activado' : '🔈 Altavoz desactivado (auricular)');
        });

        // Función para crear audio element en llamadas de voz (para mejor control de routing)
        function createRemoteAudio(peerId, stream) {
            const audioEl = document.createElement('audio');
            audioEl.autoplay = true;
            audioEl.srcObject = stream;
            audioEl.id = `remote-audio-${peerId}`;
            document.body.appendChild(audioEl);
            remoteAudioElements[peerId] = audioEl;
            return audioEl;
        }

        function removeRemoteAudio(peerId) {
            const audioEl = remoteAudioElements[peerId];
            if (audioEl) {
                audioEl.pause();
                audioEl.srcObject = null;
                audioEl.remove();
                delete remoteAudioElements[peerId];
            }
        }

        const callSelectorModal = document.getElementById('call-selector-modal');
        const callSelectorList = document.getElementById('call-selector-list');
        const callSelectorTitle = document.getElementById('call-selector-title');
        const callSelectorCancel = document.getElementById('call-selector-cancel');
        const callSelectorStart = document.getElementById('call-selector-start');
        const minimizeCallBtn = document.getElementById('minimize-call-btn');

        // --- Minimizar / Expandir llamada ---
        minimizeCallBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            callOverlay.classList.remove('active');
            callOverlay.classList.add('minimized');
        });
        callOverlay.addEventListener('click', (e) => {
            if (callOverlay.classList.contains('minimized')) {
                e.stopPropagation();
                callOverlay.classList.remove('minimized');
                callOverlay.classList.add('active');
            }
        });

        let peerConnections = {};
        let localStream = null;
        let currentGroupCallId = null;
        let currentGroupCallRef = null;
        let callTimerInterval = null;
        let callSeconds = 0;
        let currentCallWithVideo = false;
        let currentFacingMode = 'user';
        let callSignalListeners = [];
        const processedIceCandidates = new Set();
        const remoteDescSet = {};

        const rtcConfig = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
            ]
        };

        // --- Selector de participantes ---
        function showCallSelector(withVideo) {
            presenceRef.once('value').then(snap => {
                const online = snap.val() || {};
                const peers = Object.keys(online).filter(n => n !== userName && online[n] === true);
                if (peers.length === 0) {
                    alert('No hay nadie en línea para llamar');
                    return;
                }
                callSelectorTitle.textContent = withVideo ? '📹 Videollamada grupal' : '📞 Llamada grupal';
                callSelectorList.innerHTML = '';
                peers.forEach(peer => {
                    const item = document.createElement('label');
                    item.classList.add('call-selector-item');
                    item.innerHTML = `<input type="checkbox" value="${peer}" checked><span>👤 ${peer}</span>`;
                    callSelectorList.appendChild(item);
                });
                currentCallWithVideo = withVideo;
                callSelectorModal.classList.add('active');
            });
        }

        callSelectorCancel.addEventListener('click', () => {
            callSelectorModal.classList.remove('active');
        });

        callSelectorStart.addEventListener('click', () => {
            const checkboxes = callSelectorList.querySelectorAll('input[type="checkbox"]:checked');
            const selected = Array.from(checkboxes).map(cb => cb.value);
            if (selected.length === 0) { alert('Selecciona al menos una persona'); return; }
            callSelectorModal.classList.remove('active');
            startGroupCall(currentCallWithVideo, selected);
        });

        // --- Iniciar llamada grupal ---
        async function startGroupCall(withVideo, targetUsers) {
            currentCallWithVideo = withVideo;
            callOverlay.classList.add('active');
            callStatusEl.textContent = 'Llamando...';
            callPeerNameEl.textContent = targetUsers.join(', ');
            callActionsOutgoing.style.display = 'flex';
            callActionsIncoming.style.display = 'none';
            localVideo.style.display = withVideo ? 'block' : 'none';
            flipCameraBtn.style.display = withVideo ? 'flex' : 'none';
            currentFacingMode = 'user';

            try {
                try {
                    localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: withVideo ? { facingMode: { exact: 'user' } } : false });
                } catch(e) {
                    localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: withVideo });
                }
            if (withVideo) {
                localVideo.srcObject = localStream;
            } else {
                callOverlay.classList.add('voice-call');
                speakerBtn.classList.remove('speaker-on');
                speakerBtn.classList.add('speaker-off');
                speakerEnabled = false;
            }

                const groupCallsRef = database.ref(`channels/${activeChannel}/groupCalls`);
                const newCallRef = groupCallsRef.push();
                currentGroupCallId = newCallRef.key;
                currentGroupCallRef = newCallRef;

                const invited = {};
                targetUsers.forEach(u => invited[u] = true);

                await newCallRef.set({
                    initiator: userName,
                    type: withVideo ? 'video' : 'voice',
                    status: 'active',
                    timestamp: Date.now(),
                    invited: invited,
                    participants: { [userName]: true }
                });

                // Limpiar al desconectar
                newCallRef.child(`participants/${userName}`).onDisconnect().remove();

                setupSignalListeners(currentGroupCallId);

                // Auto-cancelar después de 30s si nadie se une
                setTimeout(() => {
                    if (currentGroupCallId && currentGroupCallRef) {
                        currentGroupCallRef.child('participants').once('value', snap => {
                            const parts = snap.val() || {};
                            if (Object.keys(parts).length <= 1) {
                                currentGroupCallRef.update({ status: 'ended' });
                                endGroupCall(false);
                                showToast('Nadie contestó la llamada');
                            }
                        });
                    }
                }, 30000);

            } catch(err) {
                console.error('Error al iniciar llamada grupal:', err);
                alert('No se pudo iniciar la llamada');
                endGroupCall(false);
            }
        }

        // --- Escuchar llamadas entrantes ---
        function setupGroupCallListener() {
            if (!activeChannel || !userName) return;
            const groupCallsRef = database.ref(`channels/${activeChannel}/groupCalls`);
            groupCallsRef.on('child_added', snap => {
                const call = snap.val();
                if (!call || call.status === 'ended') return;
                if (call.invited && call.invited[userName] && !currentGroupCallId) {
                    receiveGroupCall(snap.key, call);
                }
            });
            groupCallsRef.on('child_changed', snap => {
                const call = snap.val();
                if (!call) return;
                if (snap.key === currentGroupCallId && call.status === 'ended') {
                    endGroupCall(false);
                }
            });
        }

        // --- Recibir llamada grupal ---
        function receiveGroupCall(callId, call) {
            if (currentGroupCallId) return;
            callOverlay.classList.add('active');
            const invitedList = call.invited ? Object.keys(call.invited) : [];
            const callerInfo = call.initiator + (invitedList.length > 1 ? ` y ${invitedList.length} más` : '');
            callStatusEl.textContent = call.type === 'video' ? '📹 Videollamada grupal entrante' : '📞 Llamada grupal entrante';
            callPeerNameEl.textContent = callerInfo;
            callActionsOutgoing.style.display = 'none';
            callActionsIncoming.style.display = 'flex';
            localVideo.style.display = 'none';
            if (navigator.vibrate) navigator.vibrate([500, 200, 500, 200, 500]);
            playNotificationSound();
            callOverlay.dataset.incomingCallId = callId;
            callOverlay.dataset.incomingCallType = call.type;
        }

        // --- Aceptar llamada grupal ---
        acceptCallBtn.addEventListener('click', async () => {
            const callId = callOverlay.dataset.incomingCallId;
            if (!callId) return;
            const callRef = database.ref(`channels/${activeChannel}/groupCalls/${callId}`);
            const snap = await callRef.once('value');
            const call = snap.val();
            if (!call || call.status === 'ended') {
                showToast('La llamada ya terminó');
                callOverlay.classList.remove('active');
                return;
            }
            currentGroupCallId = callId;
            currentGroupCallRef = callRef;
            currentCallWithVideo = call.type === 'video';

            callActionsIncoming.style.display = 'none';
            callActionsOutgoing.style.display = 'flex';
            callStatusEl.textContent = 'Conectando...';
            localVideo.style.display = currentCallWithVideo ? 'block' : 'none';
            flipCameraBtn.style.display = currentCallWithVideo ? 'flex' : 'none';
            currentFacingMode = 'user';

            try {
                try {
                    localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: currentCallWithVideo ? { facingMode: { exact: 'user' } } : false });
                } catch(e) {
                    localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: currentCallWithVideo });
                }
            if (currentCallWithVideo) {
                localVideo.srcObject = localStream;
            } else {
                callOverlay.classList.add('voice-call');
                speakerBtn.classList.remove('speaker-on');
                speakerBtn.classList.add('speaker-off');
                speakerEnabled = false;
            }

                await callRef.child(`participants/${userName}`).set(true);
                callRef.child(`participants/${userName}`).onDisconnect().remove();

                const partSnap = await callRef.child('participants').once('value');
                const parts = partSnap.val() || {};
                const existingPeers = Object.keys(parts).filter(n => n !== userName);

                setupSignalListeners(callId);

                for (const peer of existingPeers) {
                    await createOfferToPeer(peer, callId);
                }

                if (existingPeers.length > 0) {
                    callStatusEl.textContent = 'En llamada';
                    callPeerNameEl.textContent = existingPeers.join(', ');
                    startCallTimer();
                }
            } catch(err) {
                console.error('Error al aceptar llamada grupal:', err);
                endGroupCall(true);
            }
        });

        // --- Crear oferta a un peer ---
        async function createOfferToPeer(peerId, callId) {
            const pc = new RTCPeerConnection(rtcConfig);
            peerConnections[peerId] = pc;
            if (localStream) {
                localStream.getTracks().forEach(t => pc.addTrack(t, localStream));
            }
            pc.ontrack = (event) => { addRemoteVideo(peerId, event.streams[0]); };
            pc.onconnectionstatechange = () => {
                if (pc.connectionState === 'disconnected' || pc.connectionState === 'failed') {
                    removeRemoteVideo(peerId);
                    if (peerConnections[peerId]) { peerConnections[peerId].close(); delete peerConnections[peerId]; }
                    updateCallUI();
                } else if (pc.connectionState === 'connected') {
                    updateCallUI();
                }
            };

            const signalKey = `${userName}_${peerId}`;
            const signalRef = database.ref(`channels/${activeChannel}/groupCalls/${callId}/signals/${signalKey}`);
            pc.onicecandidate = (event) => {
                if (event.candidate) { signalRef.child('ice_offerer').push(event.candidate.toJSON()); }
            };

            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            await signalRef.set({ offer: { type: offer.type, sdp: offer.sdp } });
        }

        // --- Responder a una oferta ---
        async function answerOffer(peerId, signalKey, offerData, callId) {
            if (peerConnections[peerId]) return;
            const pc = new RTCPeerConnection(rtcConfig);
            peerConnections[peerId] = pc;
            if (localStream) {
                localStream.getTracks().forEach(t => pc.addTrack(t, localStream));
            }
            pc.ontrack = (event) => { addRemoteVideo(peerId, event.streams[0]); };
            pc.onconnectionstatechange = () => {
                if (pc.connectionState === 'disconnected' || pc.connectionState === 'failed') {
                    removeRemoteVideo(peerId);
                    if (peerConnections[peerId]) { peerConnections[peerId].close(); delete peerConnections[peerId]; }
                    updateCallUI();
                } else if (pc.connectionState === 'connected') {
                    if (!callTimerInterval) startCallTimer();
                    callStatusEl.textContent = 'En llamada';
                    updateCallUI();
                }
            };

            const signalRef = database.ref(`channels/${activeChannel}/groupCalls/${callId}/signals/${signalKey}`);
            pc.onicecandidate = (event) => {
                if (event.candidate) { signalRef.child('ice_answerer').push(event.candidate.toJSON()); }
            };

            await pc.setRemoteDescription(new RTCSessionDescription(offerData));
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            await signalRef.update({ answer: { type: answer.type, sdp: answer.sdp } });
        }

        // --- Listeners de señalización ---
        function setupSignalListeners(callId) {
            const signalsRef = database.ref(`channels/${activeChannel}/groupCalls/${callId}/signals`);
            const onAdded = signalsRef.on('child_added', snap => {
                handleSignalChange(snap.key, snap.val(), callId);
            });
            const onChanged = signalsRef.on('child_changed', snap => {
                handleSignalChange(snap.key, snap.val(), callId);
            });
            callSignalListeners.push({ ref: signalsRef, event: 'child_added', cb: onAdded });
            callSignalListeners.push({ ref: signalsRef, event: 'child_changed', cb: onChanged });
        }

        function handleSignalChange(signalKey, signalData, callId) {
            if (!signalData) return;
            const parts = signalKey.split('_');
            if (parts.length < 2) return;
            const offerer = parts[0];
            const answerer = parts.slice(1).join('_');

            // Soy el answerer y hay oferta sin respuesta → responder
            if (answerer === userName && signalData.offer && !signalData.answer) {
                answerOffer(offerer, signalKey, signalData.offer, callId);
            }

            // Soy el offerer y hay respuesta → setRemoteDescription
            if (offerer === userName && signalData.answer && peerConnections[answerer]) {
                if (!remoteDescSet[answerer]) {
                    remoteDescSet[answerer] = true;
                    peerConnections[answerer].setRemoteDescription(new RTCSessionDescription(signalData.answer))
                        .catch(e => console.error('SRD error:', e));
                }
            }

            // ICE candidates
            if (offerer === userName && signalData.ice_answerer && peerConnections[answerer]) {
                addIceCandidatesToPC(peerConnections[answerer], signalData.ice_answerer);
            }
            if (answerer === userName && signalData.ice_offerer && peerConnections[offerer]) {
                addIceCandidatesToPC(peerConnections[offerer], signalData.ice_offerer);
            }
        }

        function addIceCandidatesToPC(pc, iceCandidates) {
            if (!pc || !iceCandidates) return;
            Object.entries(iceCandidates).forEach(([key, c]) => {
                if (c && c.candidate && !processedIceCandidates.has(key)) {
                    processedIceCandidates.add(key);
                    pc.addIceCandidate(new RTCIceCandidate(c)).catch(e => console.log('ICE error:', e));
                }
            });
        }

        // --- UI de video grid ---
        function addRemoteVideo(peerId, stream) {
            if (!currentCallWithVideo) {
                createRemoteAudio(peerId, stream);
                return;
            }
            let cell = document.getElementById(`video-cell-${peerId}`);
            if (!cell) {
                cell = document.createElement('div');
                cell.classList.add('call-video-cell');
                cell.id = `video-cell-${peerId}`;
                const video = document.createElement('video');
                video.autoplay = true;
                video.playsInline = true;
                video.srcObject = stream;
                const label = document.createElement('div');
                label.classList.add('video-label');
                label.textContent = peerId;
                cell.appendChild(video);
                cell.appendChild(label);
                callVideoGrid.appendChild(cell);
            } else {
                cell.querySelector('video').srcObject = stream;
            }
            updateVideoGridLayout();
        }

        function removeRemoteVideo(peerId) {
            if (!currentCallWithVideo) {
                removeRemoteAudio(peerId);
                return;
            }
            const cell = document.getElementById(`video-cell-${peerId}`);
            if (cell) cell.remove();
            updateVideoGridLayout();
        }

        function updateVideoGridLayout() {
            const count = callVideoGrid.children.length;
            callVideoGrid.className = 'call-video-grid';
            if (count <= 1) callVideoGrid.classList.add('grid-1');
            else if (count <= 2) callVideoGrid.classList.add('grid-2');
            else if (count <= 4) callVideoGrid.classList.add('grid-4');
            else callVideoGrid.classList.add('grid-6');
        }

        function updateCallUI() {
            const connectedPeers = Object.keys(peerConnections);
            if (connectedPeers.length > 0) {
                callPeerNameEl.textContent = connectedPeers.join(', ');
            }
        }

        // --- Timer ---
        function startCallTimer() {
            if (callTimerInterval) return;
            callSeconds = 0;
            callTimerEl.style.display = 'block';
            callTimerInterval = setInterval(() => {
                callSeconds++;
                const m = String(Math.floor(callSeconds / 60)).padStart(2, '0');
                const s = String(callSeconds % 60).padStart(2, '0');
                callTimerEl.textContent = `${m}:${s}`;
            }, 1000);
        }

        // --- Terminar llamada grupal ---
        function endGroupCall(updateRemote) {
            if (callTimerInterval) { clearInterval(callTimerInterval); callTimerInterval = null; }
            Object.keys(peerConnections).forEach(peerId => {
                if (peerConnections[peerId]) peerConnections[peerId].close();
            });
            peerConnections = {};
            if (localStream) { localStream.getTracks().forEach(t => t.stop()); localStream = null; }

            if (updateRemote && currentGroupCallRef) {
                currentGroupCallRef.child(`participants/${userName}`).remove();
                currentGroupCallRef.child('participants').once('value', snap => {
                    const parts = snap.val() || {};
                    if (Object.keys(parts).length === 0) {
                        currentGroupCallRef.update({ status: 'ended' });
                    }
                });
            }

            callSignalListeners.forEach(l => l.ref.off(l.event, l.cb));
            callSignalListeners = [];
            processedIceCandidates.clear();
            Object.keys(remoteDescSet).forEach(k => delete remoteDescSet[k]);

            Object.keys(remoteAudioElements).forEach(peerId => removeRemoteAudio(peerId));
            speakerEnabled = false;

            callVideoGrid.innerHTML = '';
            localVideo.srcObject = null;
            localVideo.style.display = 'none';
            flipCameraBtn.style.display = 'none';
            callOverlay.classList.remove('active');
            callOverlay.classList.remove('minimized');
            callOverlay.classList.remove('voice-call');
            callTimerEl.style.display = 'none';
            currentGroupCallId = null;
            currentGroupCallRef = null;
            delete callOverlay.dataset.incomingCallId;
            delete callOverlay.dataset.incomingCallType;
            if (navigator.vibrate) navigator.vibrate(0);
        }

        // --- Event listeners ---
        endCallBtn.addEventListener('click', () => endGroupCall(true));
        rejectCallBtn.addEventListener('click', () => {
            if (callOverlay.dataset.incomingCallId) {
                database.ref(`channels/${activeChannel}/groupCalls/${callOverlay.dataset.incomingCallId}/invited/${userName}`).remove();
            }
            endGroupCall(false);
        });

        voiceCallBtn.addEventListener('click', () => showCallSelector(false));
        videoCallBtn.addEventListener('click', () => showCallSelector(true));

        // --- Voltear cámara (group-compatible) ---
        flipCameraBtn.addEventListener('click', async () => {
            if (!localStream) return;
            flipCameraBtn.disabled = true;
            const prevFacing = currentFacingMode;
            currentFacingMode = currentFacingMode === 'user' ? 'environment' : 'user';

            const videoSenders = [];
            Object.values(peerConnections).forEach(pc => {
                const sender = pc.getSenders().find(s => s.track && s.track.kind === 'video');
                if (sender) videoSenders.push(sender);
            });

            const oldTrack = localStream.getVideoTracks()[0];
            if (oldTrack) { oldTrack.stop(); localStream.removeTrack(oldTrack); }
            await new Promise(r => setTimeout(r, 300));

            let newStream = null;
            try { newStream = await navigator.mediaDevices.getUserMedia({ audio: false, video: { facingMode: { exact: currentFacingMode } } }); } catch(e) { newStream = null; }
            if (!newStream) { try { newStream = await navigator.mediaDevices.getUserMedia({ audio: false, video: { facingMode: currentFacingMode } }); } catch(e) { newStream = null; } }
            if (!newStream) {
                currentFacingMode = prevFacing;
                try { newStream = await navigator.mediaDevices.getUserMedia({ audio: false, video: { facingMode: prevFacing } }); } catch(e) {}
                if (!newStream) { flipCameraBtn.disabled = false; return; }
            }

            const newTrack = newStream.getVideoTracks()[0];
            for (const sender of videoSenders) { await sender.replaceTrack(newTrack); }
            localStream.addTrack(newTrack);
            localVideo.srcObject = null;
            localVideo.srcObject = localStream;
            flipCameraBtn.disabled = false;
        });

        // Hook into initializeChat
        const origInitializeChat = initializeChat;
        initializeChat = function() {
            origInitializeChat();
            setupGroupCallListener();
        };
        if (activeChannel && userName) {
            setupGroupCallListener();
        }


    </script>

</body>
</html>
